<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 9: Referencias y colecciones - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"><a name="Lección 9: Referencias y colecciones"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_es.html">documentación</a> / </span>
        Lección 9: Referencias y colecciones </h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="modeling_es.html">2.
        Modelar con Java</a> | <a class="wiki_link" href="testing_es.html">3.
        Pruebas automáticas</a> | <a class="wiki_link" href="inheritance_es.html">4.
        Herencia</a> | <a class="wiki_link" href="basic-business-logic_es.html">5.
        Lógica de negocio básica</a> | <a class="wiki_link" href="validation_es.html">6.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">7.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">8.
        Comportamiento y lógica de negocio</a> | <strong>9. Referencias y
        colecciones</strong> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#comportamiento-y-logica-de-negocio">Lección
            8: Comportamiento y lógica de negocio</a></div>
        <div style="margin-left: 2em;"><a href="#logica-de-negocio-desde-el-modo-detalle">Lógica
            de negocio desde el modo detalle</a></div>
        <div style="margin-left: 3em;"><a href="#crear-una-accion-para-ejecutar-logica-personalizada">Crear
            una acción para ejecutar lógica personalizada</a></div>
        <div style="margin-left: 3em;"><a href="#escribiendo-la-logica-de-negocio-real-en-la-entidad">Escribiendo
            la lógica de negocio real en la entidad</a></div>
        <div style="margin-left: 3em;"><a href="#escribe-menos-codigo-usando-apache-commons-beanutils">Escribe
            menos código usando Apache Commons BeanUtils</a></div>
        <div style="margin-left: 3em;"><a href="#excepciones-de-aplicacion">Excepciones
            de aplicación</a></div>
        <div style="margin-left: 3em;"><a href="#validar-desde-la-accion">Validar
            desde la acción</a></div>
        <div style="margin-left: 3em;"><a href="#evento-onchange-para-ocultar-mostrar-una-accion-por-codigo">Evento
            OnChange para ocultar/mostrar una acción por código</a></div>
        <div style="margin-left: 2em;"><a href="#logica-de-negocio-desde-el-modo-lista">Lógica
            de negocio desde el modo lista</a></div>
        <div style="margin-left: 3em;"><a href="#accion-de-lista-con-logica-propia">Acción
            de lista con lógica propia</a></div>
        <div style="margin-left: 3em;"><a href="#logica-de-negocio-en-el-modelo-sobre-varias-entidades">Lógica
            de negocio en el modelo sobre varias entidades</a></div>
        <div style="margin-left: 2em;"><a href="#mostrar-un-dialogo">Mostrar un
            diálogo</a></div>
        <div style="margin-left: 3em;"><a href="#usar-showdialog">Usar
            showDialog()</a></div>
        <div style="margin-left: 3em;"><a href="#definir-las-acciones-del-dialogo">Definir
            las acciones del diálogo</a></div>
        <div style="margin-left: 3em;"><a href="#cerrar-el-dialogo">Cerrar el
            diálogo</a></div>
        <div style="margin-left: 3em;"><a href="#vista-plana-en-lugar-de-dialogo">Vista
            plana en lugar de diálogo</a></div>
        <div style="margin-left: 2em;"><a href="#pruebas-junit">Pruebas JUnit</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-de-modo-detalle">Probar
            la acción de modo detalle</a></div>
        <div style="margin-left: 3em;"><a href="#buscar-una-entidad-para-la-prueba-usando-el-modo-lista-y-jpa">Buscar
            una entidad para la prueba usando el modo lista y JPA</a></div>
        <div style="margin-left: 3em;"><a href="#probar-que-la-accion-se-oculta-cuando-no-aplica">Probar
            que la acción se oculta cuando no aplica</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-de-modo-lista">Probar
            la acción de modo lista</a></div>
        <div style="margin-left: 3em;"><a href="#verificar-datos-de-prueba">Verificar
            datos de prueba</a></div>
        <div style="margin-left: 3em;"><a href="#probar-casos-excepcionales">Probar
            casos excepcionales</a></div>
        <div style="margin-left: 2em;"><a href="#resumen">Resumen</a></div>
      </div>
      En lecciones anteriores aprendiste como añadir tus propias acciones. Sin
      embargo, esto no es suficiente para personalizar del todo el
      comportamiento de tu aplicación, porque la interfaz de usuario generada,
      en concreto la interfaz de usuario para referencias y colecciones, tiene
      un comportamiento estándar que a veces no es el más conveniente. <br>
      Por fortuna, OpenXava proporciona muchas formas de personalizar el
      comportamiento de las referencias y colecciones. En esta lección
      aprenderás como hacer algunas de estas personalizaciones, y como esto
      añade valor a tu aplicación.
      <h2>Refinar el comportamiento de las referencias</h2>
      Posiblemente te hayas dado cuenta de que el módulo Order tiene un pequeño
      defecto: el usuario puede añadir cualquier factura que quiera al pedido
      actual, aunque el cliente de la factura sea diferente. Esto no es
      admisible. Arreglémoslo.
      <h3>Las validaciones están bien, pero no son suficientes</h3>
      El usuario sólo puede asociar un pedido a una factura si ambos, factura y
      pedido, pertenecen al mismo cliente. Esto es lógica de negocio específica
      de tu aplicación, por tanto el comportamiento estándar de OpenXava no lo
      resuelve. <br>
      La siguiente imagen muestra cómo se produce un error de validación cuando
      el cliente de la factura es incorrecto: </div>
    <img src="files/references-collections_es010.png" alt="references-collections_es010"

      title="references-collections_es010">
    <div class="wiki" style="display: block;"> Ya que esto es lógica de negocio
      la vamos a poner en la capa del modelo, es decir, en las entidades. Lo
      haremos añadiendo una validación. Así obtendrás el efecto de la figura de
      arriba. <br>
      Ya sabes como añadir esta validación a tu entidad <i>Order</i>. Se trata
      de añadir un método anotado con <i>@AssertTrue</i>: <br>
      <pre><code class="java">public class Pedido {

    ...

    // Este método ha de devolver true para que este pedido sea válido
    @AssertTrue(message="cliente_pedido_factura_coincidir") 
    private boolean isClienteFacturaCoincide() {
    	return factura == null || // factura es opcional
    		factura.getCliente().getNumero() == getCliente().getNumero();
    }

}
</code></pre>También has de añadir el mensaje a <i>i18n/MensajesFacturacion_es.properties</i>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="properties">cliente_pedido_factura_coincidir=El cliente de la factura y del pedido han de coincidir
</code></pre>Aquí comprobamos que el cliente de la factura es el mismo que el
      del pedido. Esto es suficiente para preservar la integridad de los datos,
      pero la validación sola es una opción bastante pobre desde el punto de
      vista del usuario.
      <h3>Refinar la acción para buscar una referencia con una lista</h3>
      Aunque la validación impide que el usuario pueda asignar una factura
      incorrecta a un pedido, lo tiene difícil a la hora de escoger una factura
      correcta. Porque cuando pulsa para buscar una factura, todas las facturas
      existentes se muestran. Vamos a mejorar esto para mostrar solo las
      facturas del cliente del pedido visualizado, de esta manera:<br>
      <img src="files/references-collections_es020.png" alt="references-collections_es020.png"

        title="references-collections_es020.png"><br>
      Para definir nuestra propia acción de búsqueda para la referencia a
      factura usaremos la anotación <i>@SearchAction</i>. Aquí tienes la
      modificación necesaria en la clase <i>Pedido</i>:
      <pre><code class="java">public class Pedido extends DocumentoComercial {
 
    @ManyToOne
    @ReferenceView("SinClienteNiPedidos") 
    @OnChange(MostrarOcultarCrearFactura.class) 
    @SearchAction("Pedido.buscarFactura") // Define nuestra acción para buscar facturas
    Factura factura; 
    
    ...
	
}
</code></pre> De esta forma tan simple definimos la acción a ejecutar cuando el
      usuario pulsa en el botón de la linterna para buscar una factura. El
      argumento usado para <i>@SearchAction</i>, <i>Pedido.buscarFactura</i>,
      es el nombre calificado de la acción, es decir la acción <i>buscarFactura</i>
      del controlador <i>Pedido</i> definido en el archivo <i>controladores.xml</i>.<br>
      Ahora tenemos que editar <i>controladores.xml</i> y añadir la definición
      de nuestra nueva acción:
      <pre><code class="xml">&lt;controlador nombre="Pedido"&gt;

	...
	
	&lt;accion nombre="buscarFactura"
	clase="com.tuempresa.facturacion.acciones.BuscarFacturaDesdePedido"
	oculta="true" icono="magnify"/&gt;
	&lt;!--
	oculta="true" : Para que no se muestre en la barra de botones del módulo
	icono="magnify" : La misma imagen que la de la acción estándar
	--&gt;
	
&lt;/controlador&gt;
</code></pre>Nuestra acción hereda de <i> ReferenceSearchAction</i> como se
      muestra en el siguiente código:
      <pre><code class="java">package com.tuempresa.facturacion.acciones; // En el paquete 'acciones'

import org.openxava.actions.*; // Para usar ReferenceSearchAction

public class BuscarFacturaDesdePedido
    extends ReferenceSearchAction { // Lógica estándar para buscar una referencia

    public void execute() throws Exception {
        int numeroCliente =
            getView().getValueInt("cliente.numero"); // Lee de la vista el número
                                                  // de cliente del pedido actual
        super.execute(); // Ejecuta la lógica estándar, la cual muestra un diálogo
        if (numeroCliente &gt; 0) { // Si hay cliente los usamos para filtrar
            getTab().setBaseCondition("${cliente.numero} = " + numeroCliente);
        }
    }
}
</code></pre> Observa como usamos <i>getTab().setBaseCondition()</i> para
      establecer una condición en la lista para escoger la referencia. Es decir,
      desde una <i> ReferenceSearchAction</i> puedes usar <i>getTab()</i> para
      manipular la forma en que se comporta la lista.<br>
      Si no hay cliente no añadimos ninguna condición por tanto se mostrarían
      todas las facturas, esto ocurre cuando el usuario escoge la factura antes
      que el cliente.
      <h3>Buscar la referencia tecleando en los campos</h3>
      La lista para escoger una referencia ya funciona bien. Sin embargo,
      queremos dar al usuario la opción de escoger una factura sin usar la
      lista, simplemente tecleando el año y el número. Muy útil si el usuario
      conoce de antemano que factura quiere.<br>
      OpenXava provee esa funcionalidad por defecto. Si los campos <i>@Id</i>
      son visualizados en la referencia serán usados para buscar, en caso
      contrario OpenXava usa el primer campo visualizado para buscar. Aunque en
      nuestro caso esto no es tan conveniente, porque el primer campo
      visualizado es el año, y buscar una factura sólo por el año no es muy
      preciso. La siguiente imagen muestra el comportamiento por defecto junto
      con una alternativa más conveniente:<br>
      <img src="files/references-collections_es030.png" alt="references-collections_es030.png"

        title="references-collections_es030.png"><br>
      Afortunadamente es fácil indicar que campos queremos usar para buscar
      desde la perspectiva del usuario. Esto se hace por medio de la anotación <i>@SearchKey</i>.
      Edita la clase <i>DocumentoComercial</i> (recuerda, el padre de <i>Pedido</i>
      y <i>Factura</i>) y añade esta anotación a las propiedades <i>anyo</i> y
      <i>numero</i>:
      <pre><code class="java">abstract public class DocumentoComercial extends Eliminable {

    @SearchKey // Añade esta anotación aquí
    @Column(length=4)
    @DefaultValueCalculator(CurrentYearCalculator.class) 
    int anyo;
 
    @SearchKey // Añade esta anotación aquí
    @Column(length=6)
    @ReadOnly
    int numero;
	
    ...
	
}
</code></pre> De esta forma cuando el usuario busque un pedido o una factura
      desde una referencia tiene que teclear el año y el número, y la entidad
      correspondiente será recuperada de la base de datos y rellenará la
      interfaz de usuario. Ahora es fácil para el usuario escoger una factura
      desde un pedido sin usar la lista de búsqueda, simplemente tecleando el
      año y el número.
      <h3>Refinar la acción para buscar cuando se teclea la clave</h3>
      Ahora que obtener una factura tecleando el año y el número funciona
      queremos refinarlo para ayudar al usuario a hacer su trabajo de forma más
      eficiente. Por ejemplo, sería útil que si el usuario todavía no ha
      escogido al cliente para el pedido y escoge una factura, el cliente de esa
      factura sea asignado automáticamente al pedido actual. La siguiente imagen
      visualiza el comportamiento deseado:<br>
      <img src="files/references-collections_es040.png" alt="references-collections_es040.png"

        title="references-collections_es040.png"><br>
      Por otra parte, si el usuario ya ha seleccionado un cliente para el
      pedido, si no coincide con el de la factura, ésta será rechazada y se
      visualizará un mensaje de error, tal como se muestra aquí:</div>
    <img src="files/references-collections_es050.png" alt="references-collections_es050.png"

      title="references-collections_es050.png">
    <div class="wiki" style="display: block;">Para definir este comportamiento
      especial hemos de añadir una anotación en la referencia <i>factura</i> de
      <i>Pedido</i>. <i>@OnChangeSearch</i> permite definir nuestra propia
      acción para hacer la búsqueda de la referencia cuando su clave cambia en
      la interfaz de usuario. Puedes ver la referencia modificada:
      <pre><code class="java">public class Pedido extends DocumentoComercial {
 
    @ManyToOne
    @ReferenceView("SinClienteNiPedidos") 
    @OnChange(MostrarOcultarCrearFactura.class) 
    @OnChangeSearch(BuscarAlCambiarFactura.class) // Añade esta anotación
    @SearchAction("Pedido.buscarFactura") // Define nuestra acción para buscar facturas
    Factura factura; 
    
    ...
	
}
</code></pre> A partir de ahora cuando un usuario teclee un nuevo año y número
      para la factura, <i>BuscarAlCambiarFactura</i> se ejecutará. En esta
      acción se han de leer los datos de la factura de la base de datos y
      actualizar la interfaz de usuario. A continuación el código de la acción:
      <pre><code class="java">package com.tuempresa.facturacion.actiones; // En el paquete 'acciones'

import java.util.*;
import org.openxava.actions.*; // Para usar OnChangeSearchAction
import org.openxava.model.*;
import org.openxava.view.*;
import com.tuempresa.facturacion.modelo.*;

public class BuscarAlCambiarFactura  
    extends OnChangeSearchAction { // Lógica estándar para buscar una referencia cuando
                                   // los valores clave cambian en la interfaz de usuario (1)
    public void execute() throws Exception {
        super.execute(); // Ejecuta la lógica estándar (2)
        Map clave = getView() // getView() aquí es la de la referencia, no la principal(3)
            .getKeyValuesWithValue();
        if (clave.isEmpty()) return;  // Si la clave está vacía no se ejecuta más lógica
        Factura factura = (Factura) // Buscamos la factura usando la clave tecleada (4)
            MapFacade.findEntity(getView().getModelName(), clave);
        View vistaCliente = getView().getRoot().getSubview("cliente"); // (5)
        int numeroCliente = vistaCliente.getValueInt("numero");
        if (numeroCliente == 0) { // Si no hay cliente lo llenamos (6)
            vistaCliente.setValue("numero", factura.getCliente().getNumero());
            vistaCliente.refresh();
        } 
        else { // Si ya hay un cliente verificamos que coincida con el cliente de la factura (7)
            if (numeroCliente != factura.getCliente().getNumero()) {
                addError("cliente_factura_no_coincide", 
                    factura.getCliente().getNumero(), factura, numeroCliente);
                getView().clear();
            }
        }
    }
}	
</code></pre> Dado que la acción desciende de <i>OnChangeSearchAction</i> (1) y
      usamos <i>super.execute()</i> (2) se comporta de la forma estándar, es
      decir, cuando el usuario teclea el año y el número los datos de la factura
      se recuperan y rellenan la interfaz de usuario. Después, usamos <i>getView()</i>
      (3) para obtener la clave de la factura visualizada y así encontrar su
      correspondiente entidad usando <i>MapFacade</i> (4). Desde dentro de una
      <i>OnChangeSearchAction</i> <i>getView()</i> devuelve la subvista de la
      referencia, y no la vista global. Por lo tanto, en este caso <i>getView()</i>
      es la vista de la referencia a factura. Esto permite crear acciones <i>@OnChangeSearch</i>
      más reutilizables. Has de escribir <i>getView().getRoot().getSubview(“cliente”)</i>
      (5) para acceder a la vista del cliente.&nbsp; <br>
      Para implementar el comportamiento visualizado en la imagen anterior, la
      acción pregunta si no hay cliente (<i>numeroCliente == 0</i>) (6). Si éste
      es el caso rellena los datos del cliente desde el cliente de la factura.
      En caso contrario implementa la lógica de la imagen de arriba verificando
      que el cliente del pedido actual coincide con el cliente de la factura
      recuperada.<br>
      Nos queda un pequeño detalle, el texto del mensaje. Añade la siguiente
      entrada al archivo <i>MensajesFacturacion_es.properties</i> de la carpeta
      <i>i18n</i>:
      <pre><code class="properties">cliente_factura_no_coincide=Cliente Nº {0} de la factura {1} no coincide con el cliente Nº {2} del pedido actual
</code></pre> Una cosa interesante de <i>@OnChangeSearch</i> es que también se
      ejecuta si la factura se escoge desde la lista, porque en este caso el año
      y el número también cambian. Por ende, este es un lugar centralizado donde
      refinar la lógica para recuperar la referencia y rellenar la vista.
      <h2>Refinar el comportamiento de las colecciones</h2>
      Podemos refinar las colecciones de la misma forma que hemos hecho con las
      referencias. Esto es muy útil, porque nos permite mejorar el
      comportamiento actual del módulo <i>Factura</i>. El usuario sólo puede
      añadir un pedido a una factura si la factura y el pedido pertenecen al
      mismo cliente. Además, el pedido tiene que estar entregado y no tener
      todavía factura.
      <h3>Refinar la lista para añadir elementos a la colección</h3>
      Actualmente cuando el usuario trata de añadir pedidos a la factura todos
      los pedidos están disponibles. Vamos a mejorar esto para mostrar solo los
      pedidos del cliente de la factura, entregados y todavía sin factura, tal
      como se muestra: <br>
      <img src="files/references-collections_es060.png" alt="references-collections_es060.png"

        title="references-collections_es060.png"><br>
      Usaremos la anotación <i>@AddAction</i> para definir nuestra propia
      acción que muestre la lista para añadir pedidos. El siguiente código
      muestra la modificación necesaria en la clase <i>Factura</i>:
      <pre><code class="java">public class Factura extends DocumentoComercial {
 
    @OneToMany(mappedBy="factura")
    @CollectionView("SinClienteNiFactura") 
    @AddAction("Factura.anyadirPedidos") // Define nuestra propia acción para añadir pedidos
    Collection&lt;Pedido&gt; pedidos;
	
    ...
	
}
</code></pre> De esta forma tan sencilla definimos la acción a ejecutar cuando
      el usuario pulsa en el botón para añadir pedidos. El argumento usado para
      <i>@AddAction</i>, <i>Factura.anyadirPedidos</i>, es el nombre calificado
      de la acción, es decir la acción <i>añadirPedidos</i> del controlador <i>Factura</i>
      tal como se ha definido en el archivo <i>controladores.xml</i>.<br>
      Ahora hemos de editar <i>controladores.xml</i> para añadir el controlador
      <i>Factura</i> (todavía no existe) con nuestra acción:
      <pre><code class="xml">&lt;controlador nombre="Factura"&gt;
    &lt;hereda-de controlador="Facturacion"/&gt;

    &lt;accion nombre="anyadirPedidos"
        clase="com.tuempresa.facturacion.acciones.IrAnyadirPedidosAFactura"
        oculta="true" icono="table-row-plus-after"/&gt;
        &lt;!--
        oculta="true" : No se mostrará en la barra de botones del módulo
        icono="table-row-plus-after" : La misma imagen que la acción estándar
        --&gt;

&lt;/controlador&gt;
</code></pre>Este es el código de la acción:
      <pre><code class="java">package com.tuempresa.facturacion.acciones; // En el paquete 'acciones'

import org.openxava.actions.*; // Para usar GoAddElementsToCollectionAction

public class IrAnyadirPedidosAFactura
    extends GoAddElementsToCollectionAction { // Lógica estándar para ir a la lista que
                                              // permite añadir elementos a la colección
    public void execute() throws Exception {
        super.execute(); // Ejecuta la lógica estándar, la cual muestra un diálogo
        int numeroCliente =
            getPreviousView() // getPreviousView() es la vista principal (estamos en un diálogo)
                .getValueInt("cliente.numero"); // Lee el número de cliente de la
                                                // factura actual de la vista
        getTab().setBaseCondition( // La condición de la lista de pedidos a añadir
            "${cliente.numero} = " + numeroCliente +
            " and ${entregado} = true and ${factura} is null"
        );
    }
}
</code></pre> Fíjate como usamos <i>getTab().setBaseCondition()</i> para
      establecer la condición de la lista para escoger la entidades a añadir. Es
      decir, desde una <i>GoAddElementsToCollectionAction</i> puedes usar <i>getTab()</i>
      para manipular la forma en que la lista se comporta.
      <h3>Refinar la acción que añade elementos a la colección</h3>
      Una mejora interesante para la colección de pedidos sería que cuando el
      usuario añada pedidos a la factura actual, las líneas de detalle de estos
      pedidos se copien automáticamente a la factura.<br>
      No podemos usar <i>@AddAction</i> para esto, porque es la acción que
      muestra la lista de elementos a añadir a la colección. Pero no es la
      acción que añade los elementos. En esta sección aprenderemos como definir
      la acción que realmente añade los elementos: <br>
      <img src="files/references-collections_es070.png" alt="references-collections_es070.png"

        title="references-collections_es070.png"><br>
      Por desgracia, no hay una anotación para definir directamente esta acción
      de añadir. Sin embargo, no es una tarea demasiado difícil, solo hemos de
      refinar la acción <i>@AddAction</i> instruyéndola para mostrar nuestro
      propio controlador y en este controlador podemos poner las acciones que
      queramos. Dado que ya hemos definido nuestra <i>@AddAction</i> en la
      sección anterior solo hemos de añadir un nuevo método a la ya existente <i>IrAnyadirPedidosAFactura</i>.
      Añade el siguiente método <i>getNextController()</i> a tu acción:
      <pre><code class="java">public class IrAnyadirPedidosAFactura ... {

    ...

    public String getNextController() { // Añadimos este método
        return "AnyadirPedidosAFactura"; // El controlador con las acciones disponibles
    }                                    // en la lista de pedidos a añadir
}
</code></pre> Por defecto las acciones en la lista de entidades a añadir (los
      botones 'Add' y 'Cancel') son del controlador estándar de OpenXava
      AddToCollection. Sobrescribir getNextController() en nuestra acción nos
      permite definir nuestro propio controlador en su lugar. Añade en <i>controladores.xml</i>
      la siguiente definición para nuestro controlador propio para añadir
      elementos:
      <pre><code class="xml">&lt;controlador nombre="AnyadirPedidosAFactura"&gt;
    &lt;hereda-de controlador="AddToCollection" /&gt; &lt;!-- Extiende del controlador estándar --&gt;
	
    &lt;!-- Sobrescribe la acción para añadir --&gt;
    &lt;accion nombre="add"
        clase="com.tuempresa.facturacion.acciones.AnyadirPedidosAFactura" /&gt;
		
&lt;/controlador&gt;
</code></pre> De esta forma la acción para añadir pedidos a la factura será <i>AnyadirPedidosAFactura</i>.
      Recuerda que el objetivo de nuestra acción es añadir los pedidos a la
      factura de la manera convencional, pero también copiar las líneas de estos
      pedidos a la factura. Este es el código de la acción:
      <pre><code class="java">package com.tuempresa.facturacion.acciones; // En el paquete 'acciones'

import java.rmi.*;
import java.util.*;
import javax.ejb.*;
import org.openxava.actions.*; // Para usar AddElementsToCollectionAction
import org.openxava.model.*;
import org.openxava.util.*;
import org.openxava.validators.*;
import com.tuempresa.facturacion.modelo.*;

public class AnyadirPedidosAFactura
    extends AddElementsToCollectionAction { // Lógica estándar para añadir
                                            // elementos a la colección
    public void execute() throws Exception {
        super.execute(); // Usamos la lógica estándar "tal cual"
        getView().refresh(); // Para visualizar datos frescos, incluyendo los importes
    }                        // recalculados, que dependen de las líneas de detalle

    protected void associateEntity(Map clave) // El método llamado para asociar
        throws ValidationException, // cada entidad a la principal, en este caso para
            XavaException, ObjectNotFoundException,// asociar cada pedido a la factura
            FinderException, RemoteException
    {
        super.associateEntity(clave); // Ejecuta la lógica estándar (1)
        Pedido pedido = (Pedido) MapFacade.findEntity("Pedido", clave); // (2)
        pedido.copiarDetallesAFactura(); // Delega el trabajo principal en la entidad (3)
    }
}
</code></pre> Sobrescribimos el método <i>execute()</i> sólo para refrescar la
      vista después del proceso. Realmente, lo que nosotros queremos es refinar
      la lógica de asociar un pedido a la factura. La forma de hacer esto es
      sobrescribiendo el método <i>associateEntity()</i>. La lógica aquí es
      simple, después de ejecutar la lógica estándar (1) buscamos la entidad <i>Pedido</i>
      correspondiente y entonces llamamos al método <i>copiarDetallesAFactura()</i>
      de ese <i>Pedido</i>. Por suerte ya teníamos un método para copiar
      detalles desde una entidad <i>Pedido</i> a la <i>Factura</i>
      especificada, simplemente llamamos a este método.</div>
    <div class="wiki" style="display: block;">Ahora solo has de crear una
      factura nueva, escoger un cliente y añadir pedidos. Es incluso más fácil
      de usar que el modo lista del módulo <i>Pedido</i> ya que el módulo <i>Factura</i>
      solo se muestran los pedidos adecuados al cliente.
      <h2>Pruebas JUnit</h2>
      Todavía tenemos la sana costumbre de hacer un poco de código de
      aplicación, y después un poco de código de pruebas. Y ahora es el tiempo
      de escribir el código de pruebas para las nuevas características añadidas
      en esta lección.
      <h3>Adaptar <i>PruebaPedido</i></h3>
      Si ejecutaras <i>PruebaPedido</i> ahora, no pasaría. Esto es porque
      nuestro código confía en ciertos detalles que han cambiado. Por lo tanto,
      hemos de modificar nuestro código de pruebas actual. Edita el método <i>
        testPonerFactura()</i> de <i>PruebaPedido</i> y aplica los siguientes
      cambios:
      <pre><code class="java">public void testPonerFactura() throws Exception {

    ...

    assertValue("factura.numero", "");
    assertValue("factura.anyo", "");
    // execute("Reference.search", // Ya no usamos la acción estándar para
    //    "keyProperty=factura.anyo"); // buscar la factura, en su lugar
    execute("Pedido.buscarFactura", // usamos nuestra acción personalizada (1)
        "keyProperty=factura.numero");
    execute("List.orderBy", "property=numero");

    ...
	
    // Restaurar valores
    setValue("entregado", "false");
    setValue("factura.anyo", ""); // Ahora es necesario teclear el año
    setValue("factura.numero", ""); // y el número para buscar la factura (2)
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Recuerda que anotamos la referencia <i>factura</i> en <i>Pedido</i>
      con <i>@SearchAction("Pedido.buscarFactura")</i>, por tanto hemos de
      modificar la prueba para llamar a <i>Pedido.buscarFactura</i> (1) en vez
      de a <i>Reference.search</i>. También añadimos <i>@SearchKey</i> a <i>anyo</i>
      y <i>numero</i> de <i>CommercialDocument</i>, por lo tanto nuestra
      prueba ha de indicar <i>anyo</i> tanto como <i>numero</i> para obtener
      (o en este caso borrar) una factura (2). Por causa de esto último también
      hemos de modificar <i> testCrearFacturaDesdePedido()</i> de <i>PruebaPedido</i>
      como se muestra:
      <pre><code class="java">public void testCrearFacturaDesdePedido() throws Exception {

    ...

    // Restaurar el pedido para ejecutar la prueba la siguiente vez
    setValue("factura.anyo", ""); // Ahora es necesario teclear el año
    setValue("factura.numero", ""); // y el número para buscar la factura (2)
    assertValue("factura.numero", "");
    assertCollectionRowCount("factura.detalles", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Después de estos cambios <i>PruebaPedido</i> tiene que pasar. Sin
      embargo, todavía nos queda probar la nueva funcionalidad del módulo <i>Pedido</i>.
      <h3>Probar <i>@SearchAction</i></h3>
      Hemos usado <i>@SearchAction</i> en la referencia <i>factura</i> de <i>Pedido</i>
      para mostrar en la lista de búsqueda solo facturas del cliente del pedido
      actual. Esta es la prueba de esta funcionalidad :
      <pre><code class="java">public void testBuscarFacturaDesdePedido() throws Exception {
    execute("CRUD.new");
    setValue("cliente.numero", "1"); // Si el cliente es 1...
    execute("Sections.change", "activeSection=1");
    execute("Pedido.buscarFactura", // ...cuando el usuario pulsa para escoger una factura...
        "keyProperty=factura.numero");
    confirmarClienteEnTodasFilas("1"); // ...sólo se muestran las facturas del cliente 1
    execute("ReferenceSearch.cancel");
    execute("Sections.change", "activeSection=0");
    setValue("cliente.numero", "2"); // Y si el cliente es 2...
    execute("Sections.change", "activeSection=1");
    execute("Pedido.buscarFactura", // ...cuando el usuario pulsa para escoger una factura...
        "keyProperty=factura.numero");
    assertCustomerInList("2"); // ...sólo se muestran las facturas del cliente 2
}
</code></pre> La parte más peliaguda es verificar la lista de facturas, este es
      el trabajo <i>confirmarClienteEnTodasFilas()</i>: <br>
      <pre><code class="java">private void confirmarClienteEnTodasFilas(String numeroCliente) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) { // Un bucle por todas las filas
        if (!numeroCliente.equals(getValueInList(i, "cliente.numero"))) {
            fail("Cliente en fila " + i + // Si el cliente no es el esperado falla
                " no es " + customerNumber);
        }
    }
}
</code></pre> Consiste en un bucle por todas la filas verificando el número de cliente.
      <h3>Probar @OnChangeSearch</h3>
      En la sección 9.1.5 usamos @SearchAction en la referencia invoice de Order
      para asignar automáticamente el cliente de la factura escogida al pedido
      actual cuando el usuario todavía no tiene cliente, o para verificar que el
      cliente de la factura y del pedido coinciden, si el pedido ya tiene
      cliente. El listado 9.22 muestra el método de prueba en OrderTest.
      <pre>Listado 9.22 Probar los eventos al cambiar la factura de un pedido
public void testOnChangeInvoice() throws Exception {
execute("CRUD.new"); // Estamos creando un nuevo pedido
assertValue("customer.number", ""); // por tanto no tiene cliente todavía
execute("Sections.change", "activeSection=1");
execute("Order.searchInvoice", // Busca la factura usando una lista
"keyProperty=invoice.number");
execute("List.orderBy", "property=customer.number"); // Ordena por cliente
String customer1Number = getValueInList(0, "customer.number"); // Memoriza..
String invoiceYear1 = getValueInList(0, "year"); // ...los datos de la...
String invoiceNumber1 = getValueInList(0, "number"); // ...primera factura
execute("List.orderBy", "property=customer.number"); // Ordena por cliente
String customer2Number = getValueInList(0, "customer.number"); // Memoriza...
String customer2Name = getValueInList(0, "customer.name"); // ...los datos de...
...la última factura
assertNotEquals("Must be invoices of different customer",
customer1Number, customer2Number);// Las 2 facturas memorizadas no son la misma
execute("ReferenceSearch.choose","row=0"); // La factura se escoge con la lista (1)
execute("Sections.change", "activeSection=0");
assertValue("customer.number", customer2Number); // Los datos del cliente
assertValue("customer.name", customer2Name);
// se rellenan automáticamente (2)
execute("Sections.change", "activeSection=1");
setValue("invoice.year", invoiceYear1); // Tratamos de poner una factura de...
setValue("invoice.number", invoiceNumber1); // ...otro cliente (3)
assertError("Customer Nº " + customer1Number + " of invoice " + // Muestra...
invoiceYear1 + "/" + invoiceNumber1 +
// ...un mensaje de error... (4)
" does not match with Customer Nº " +
customer2Number + " of the current order");

}

assertValue("invoice.year", ""); // ...y reinicia los datos de la factura (5)
assertValue("invoice.number", "");
assertValue("invoice.date", "");
</pre> Aquí probamos que nuestra acción on-change rellene los datos del cliente
      (3) al escoger una factura (2), y que si el cliente ya está establecido se
      muestre un mensaje de error (4) y la factura se borre de la vista (5).
      Fíjate como la primera vez usamos la lista (1) para escoger la factura y
      la segunda lo hacemos tecleando el año y el número (3).
      <h3>Adaptar InvoiceTest</h3>
      Como en el caso de OrderTest, InvoiceTest también falla. Has de hacer unos
      pequeños ajustes para que funcione. Edita testAddOrders() de InvoiceTest y
      aplica los cambios del listado 9.23.
      <pre>Listado 9.23 Modificaciones en el método testAddOrders() de InvoiceTest
public void testAddOrders() throws Exception {
assertListNotEmpty();
execute("List.orderBy", "property=number");
execute("Mode.detailAndFirst");
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Collection.add", // La acción estándar para añadir pedidos ya no se usa
execute("Invoice.addOrders", // En su lugar usamos nuestra propia acción
"viewObject=xava_view_section1_orders");
checkFirstOrderWithDeliveredEquals("Yes"); // Ahora todos los pedidos de la lista
checkFirstOrderWithDeliveredEquals("No"); // están entregados; esto ya no hace falta
execute("AddToCollection.add"); // En lugar de la acción estándar
execute("AddOrdersToInvoice.add", "row=0"); // ...ahora tenemos la nuestra propia
assertError("ERROR! 1 element(s) NOT added to Orders of Invoice"); // Es
// imposible porque el usuario no puede escoger pedidos incorrectos
assertMessage("1 element(s) added to Orders of Invoice");
assertCollectionRowCount("orders", 1);
checkRowCollection("orders", 0);
execute("Collection.removeSelected",
"viewObject=xava_view_section1_orders");
assertCollectionRowCount("orders", 0);
}
</pre> Ya no necesitamos el método checkFirstOrderWithDeliveredEquals(), por
      tanto podemos quitarlo de InvoiceTest (listado 9.24).
      <pre>Listado 9.24 Quitar checkFirstOrderWithDeliveredEquals() de InvoiceTest
private void checkFirstOrderWithDeliveredEquals(String value)
throws Exception { … }
</pre> Después de estos cambios InvoiceTest ha de funcionar. Sin embargo,
      todavía nos queda probar la nueva funcionalidad del módulo Invoice.
      <h3>Probar @NewAction</h3>
      En la sección 9.2.2 anotamos la colección orders de Invoice con para
      refinar la lista de pedidos a ser añadidos a la colección. De esta forma
      solo los pedidos entregados del cliente de la factura actual y todavía sin
      facturar se mostraban. Vamos a probar esto, y al mismo tiempo,
      aprenderemos como refactorizar el código existente para poder
      reutilizarlo. <br>
      @NewAction <br>
      Primero queremos verificar que la lista para añadir pedidos solo contiene
      pedidos del cliente actual. El listado 9.25 muestra los cambios en
      testAddOrders() para conseguir esto.
      <pre>Listado 9.25 Verificar que todos los pedidos en la lista son del cliente actual
public void testAddOrders() throws Exception {
assertListNotEmpty();
execute("List.orderBy", "property=number");
execute("Mode.detailAndFirst");
String customerNumber = getValue("customer.number"); // Tomamos nota del
execute("Sections.change", "activeSection=1");
// cliente de la factura
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber); // Confirmamos que todos los cliente en
// la lista coinciden con el cliente de la factura
...
}
</pre> Ahora hemos de escribir el método assertCustomerInList(). Pero, espera un
      momento, ya hemos escrito este método en OrderTest. Lo vimos en el listado
      12.34 (sección 9.3.2). Estamos en InvoiceTest por tanto no podemos llamar
      a este método. Por fortuna tanto InvoiceTest como OrderTest heredan de
      CommercialDocumentTest, por lo tanto sólo tenemos que subir el método a la
      clase madre. Para hacer esto copia el método assertCustomerInList() desde
      OrderTest a CommercialDocumentTest, cambiando private por protected, tal
      como muestra el listado 9.26.
      <pre>Listado 9.26 assertCustomerInList() movido a CommercialDocumentTest
abstract public class CommercialDocumentTest extends ModuleTestBase {
private protected void // Cambiamos de private a protected
assertCustomerInList(String customerNumber) throws Exception {
...
}
...
}
</pre> Ahora puedes quitar el método assertCustomerInList() de OrderTest
      (listado 9.27).
      <pre>Listado 9.27 assertCustomerInList() quitado de OrderTest
public class OrderTest extends CommercialDocumentTest {
private void assertCustomerInList(String customerNumber)
throws Exception { ... }
...
}
</pre> Después de estos cambios el método testAddOrders() compila y funciona. No
      solo queremos comprobar que la lista de pedidos son del cliente correcto,
      sino también que están entregados. Nuestro primer impulso es copiar y
      pegar assertCustomerInList() para crear un método assertDeliveredInList().
      Sin embargo, resistimos la tentación, y en vez de eso vamos a crear un
      método reutilizable. Primero, copiamos y pegamos assertCustomerInList()
      como assertValueForAllRows(). El listado 9.28 muestra estos dos métodos en
      CommercialDocumentTest.
      <pre>Listado 9.28 Crear assertValueForAllRows() a partir de assertCustomerInList()
protected void assertCustomerInList(String customerNumber) throws Exception {
assertListNotEmpty();
int c = getListRowCount();
for (int i=0; i&lt;c; i++) {
if (!customerNumber.equals(
getValueInList(i, "customer.number")))
// Preguntamos por el cliente
{
// de forma fija
fail("Customer in row " + i + " is not of customer "
+ customerNumber);
}
}
}
protected void assertValueForAllRows(int column, String value)
throws Exception
{
assertListNotEmpty();
int c = getListRowCount();
for (int i=0; i&lt;c; i++) {
if (!value.equals(
getValueInList(i, column))) // Preguntamos por la columna
{
// enviada como parámetro
fail("Column " + column + " in row " + i + " is not " + value);
}
}
</pre> Puedes ver como con unas ligeras modificaciones hemos convertido en un
      método genérico para preguntar por el valor de cualquier columna, no solo
      por la del número de cliente. Ahora hemos de quitar el código redundante,
      puedes, bien quitar assertCustomerInList() o bien reimplementarlo usando
      el nuevo método. El listado 9.29 muestra la última opción. <br>
      assertCustomerInList() <br>
      <pre>Listado 9.29 Reimplementar assertCustomerInList() llamando al nuevo método
protected void assertCustomerInList(String customerNumber) throws Exception {
assertValueForAllRows(3, customerNumber); // Número de cliente está en la columna 3
}
</pre> Usemos assertValueForAllRows() para verificar que la lista de pedidos
      contiene solo pedidos entregados. El listado 9.30 muestra la modificación
      necesaria en testAddOrders() de InvoiceTest.
      <pre>Listado 9.30 Confirmar que todos los pedidos están entregados
public void testAddOrders() throws Exception {
assertListNotEmpty();
execute("List.orderBy", "property=number");
execute("Mode.detailAndFirst");
String customerNumber = getValue("customer.number");
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
// Todas las celdas de la columna 5 (delivered)
// tienen 'Yes'
...
}
</pre> Además, queremos que solo los pedidos sin factura se muestren en la
      lista. Una forma sencilla de hacerlo es verificando que después de añadir
      un pedido a la factura actual, la lista de pedidos tenga una entrada
      menos. El listado 9.31 muestra los cambios necesarios en testAddOrders()
      para hacer esto.
      <pre>Listado 9.31 Probar que los pedidos ya añadidos no pueden añadirse otra vez
public void testAddOrders() throws Exception {
...
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
int ordersRowCount = getListRowCount(); // Tomamos nota de la cantidad de pedidos
execute("AddOrdersToInvoice.add", "row=0"); // cuando se muestra la lista
assertMessage("1 element(s) added to Orders of Invoice");
assertCollectionRowCount("orders", 1); // Se añadió un pedido
execute("Invoice.addOrders", // Mostramos la lista de pedidos otra vez
"viewObject=xava_view_section1_orders");
assertListRowCount(ordersRowCount – 1); // Tenemos un pedido menos en la lista
execute("AddToCollection.cancel");
...
}
</pre> Con el código de esta sección hemos probado la @NewAction de la colección
      orders, y al mismo tiempo hemos visto como no es necesario crear código
      genérico desde el principio, porque no es difícil convertir el código
      concreto en genérico bajo demanda.
      <h3>Probar la acción para añadir elementos a la colección</h3>
      En la sección 9.2.3 aprendimos como refinar la acción para añadir pedidos
      a la factura, ahora es el momento de escribir su correspondiente código de
      prueba. Recuerda que esta acción copia las líneas de los pedidos
      seleccionados a la factura actual. El listado 9.32 muestra los cambios
      para probar nuestra acción personalizada para añadir pedidos.
      <pre>Listado 9.32 Cuando un pedido se añade sus líneas se añaden a la factura
public void testAddOrders() throws Exception {
...
String customerNumber = getValue("customer.number");
deleteDetails(); // Borra la líneas de detalle si las hay (1)
assertCollectionRowCount("details", 0); // Ahora la factura no tiene detalles
assertValue("baseAmount", "0.00"); // Sin detalles el importe base es 0
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders", // Cuando mostramos la lista de pedidos (2) ...
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
String firstOrderBaseAmount = getValueInList(0, 8); //..tomamos nota del importe
int ordersRowCount = getListRowCount(); // base del primer pedido de la lista (3)
...
assertCollectionRowCount("orders", 1);
execute("Sections.change", "activeSection=0");
assertCollectionNotEmpty("details"); // Hay detalles, han sido copiados (4)
assertValue("baseAmount", firstOrderBaseAmount);
execute("Sections.change", "activeSection=1");

// El importe base de la factura
// coincide con el del
// pedido recién añadido (5)

...
}
</pre> Quitamos las líneas de detalle de la factura (1), después añadimos un
      pedido (2), tomando nota de su importe base (3), entonces verificamos que
      la factura actual tiene detalles (4) y que su importe base es el mismo que
      el del pedido añadido (5). Nos queda el método deleteDetails(), mostrado
      en el listado 9.33.
      <pre>Listado 9.33 Borra todos los detalles de la factura visualizada
private void deleteDetails() throws Exception {
int c = getCollectionRowCount("details");
for (int i=0; i&lt;c; i++) { // Un bucle por todas las filas
checkRowCollection("details", i); // Marca cada fila
}
execute("Collection.removeSelected", // Borra las filas marcadas
"viewObject=xava_view_section0_details");
}
</pre> Selecciona todas las filas de la colección details y pulsa en el botón
      'Remove selected'. El método testAddOrders() está acabado. Puedes ver su
      código definitivo en el listado 9.34.
      <pre>Listado 9.34 Código definitivo para testAddOrders() de InvoiceTest
public void testAddOrders() throws Exception {
assertListNotEmpty();
execute("List.orderBy", "property=number");
execute("Mode.detailAndFirst");
String customerNumber = getValue("customer.number");
deleteDetails();
assertCollectionRowCount("details", 0);
assertValue("baseAmount", "0.00");
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
String firstOrderBaseAmount = getValueInList(0, 8);
int ordersRowCount = getListRowCount();
execute("AddOrdersToInvoice.add", "row=0");
assertMessage("1 element(s) added to Orders of Invoice");
assertCollectionRowCount("orders", 1);
execute("Sections.change", "activeSection=0");
assertCollectionNotEmpty("details");
assertValue("baseAmount", firstOrderBaseAmount);
execute("Sections.change", "activeSection=1");
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertListRowCount(ordersRowCount - 1);
execute("AddToCollection.cancel");
checkRowCollection("orders", 0);
execute("Collection.removeSelected",
"viewObject=xava_view_section1_orders");
assertCollectionRowCount("orders", 0);
</pre> Hemos finalizado el código de las pruebas automáticas. Ahora puedes
      ejecutar todas las pruebas de tu proyecto. Han de salir en color verde.
      <h2>Resumen</h2>
      Esta lección te ha mostrado como refinar el comportamiento estándar de las
      referencias y colecciones para que tu aplicación se adapte a las
      necesidades del usuario. Aquí sólo has visto algunos ejemplos
      ilustrativos. OpenXava ofrece muchas más posibilidades para refinar el
      comportamiento de las colecciones y referencias, con anotaciones como
      @ReferenceView, @ReadOnly, @NoFrame, @NoCreate, @NoModify, @NoSearch,
      @AsEmbedded, @SearchAction, @DescriptionsList, @LabelFormat, @Action,
      @OnChange, @OnChangeSearch, @Editor, @CollectionView, @EditOnly,
      @ListProperties, @RowStyle, @EditAction, @ViewAction, @NewAction,
      @SaveAction, @HideDetailAction, @RemoveAction, @RemoveSelectedAction,
      @ListAction, @DetailAction o @OnSelectElementAction. <br>
      Y por si esto fuera poco, siempre tienes la opción definir tu propio
      editor para referencias o colecciones. Los editores te permiten crear una
      interfaz de usuario personalizada para visualizar y editar la referencia o
      colección. <br>
      Esta flexibilidad te permite usar la generación automática de la interfaz
      gráfica para prácticamente cualquier caso posible en las aplicaciones de
      gestión de la vida real. <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-8-business-logic-behavior_es.zip/download"

          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"

          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="references-collections_es.html">Ve a la
          lección 9</a></strong> </div>
  </body>
</html>
