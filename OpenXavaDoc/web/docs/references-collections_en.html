<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lesson 9: References &amp; collections - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"><a name="Lesson 9: References &amp; collections"></a> <span
          id="breadcrumbs"> <span id="openxava"> <a href="https://www.openxava.org/">
              <span>o</span>pen<span>x</span>ava </a> </span> / <a href="index_en.html">documentation</a>
          / </span> Lesson 9: References &amp; collections </h1>
      <strong>Course</strong>: <a class="wiki_link" href="getting-started_en.html">1.
        Getting started</a> | <a class="wiki_link" href="modeling_en.html">2.
        Modeling with Java</a> | <a class="wiki_link" href="testing_en.html">3.
        Automated testing</a> | <a class="wiki_link" href="inheritance_en.html">4.
        Inheritance</a> | <a class="wiki_link" href="basic-business-logic_en.html">5.
        Basic business logic</a> | <a class="wiki_link" href="validation_en.html">6.
        Advanced validation</a> | <a class="wiki_link" href="refining-standard-behavior_en.html">7.
        Refining the standard behavior</a> | <a class="wiki_link" href="business-logic-behavior_en.html">8.
        Behavior &amp; business logic</a> | <strong>9. References &amp;
        collections</strong> | <a class="wiki_link" href="philosophy_en.html">A.
        Architecture &amp; philosophy</a> | <a class="wiki_link" href="jpa_en.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_en.html">C.
        Annotations</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Table of contents</h1>
        <div style="margin-left: 1em;"><a href="#business-logic-behavior">Lesson
            8: Behavior &amp; business logic<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#business-logic-in-detail-mode">Business
            logic in detail mode</a></div>
        <div style="margin-left: 3em;"><a href="#creating-an-action-for-custom-logic">Creating
            an action for custom logic</a></div>
        <div style="margin-left: 3em;"><a href="#writing-the-real-business-logic-in-the-entity">Writing
            the real business logic in the entity</a></div>
        <div style="margin-left: 3em;"><a href="#write-less-code-using-apache-commons-beanutils">Write
            less code using Apache Commons BeanUtils</a></div>
        <div style="margin-left: 3em;"><a href="#copying-a-collection-from-entity-to-entity">Application
            exceptions</a></div>
        <div style="margin-left: 3em;"><a href="#validation-from-action">Validation
            from action</a></div>
        <div style="margin-left: 3em;"><a href="#on-change-event-to-hide-show-an-action-programmatically">On
            change event to hide/show an action programmatically</a></div>
        <div style="margin-left: 2em;"><a href="#business-logic-from-list-mode">Business
            logic from list mode</a></div>
        <div style="margin-left: 3em;"><a href="#list-action-with-custom-logic">List
            action with custom logic</a></div>
        <div style="margin-left: 3em;"><a href="#business-logic-in-the-model-over-several-entities">Business
            logic in the model over several entities</a></div>
        <div style="margin-left: 2em;"><a href="#Showing-a-dialog">Showing a
            dialog</a></div>
        <div style="margin-left: 3em;"><a href="#using-showdialog">Using
            showDialog()</a></div>
        <div style="margin-left: 3em;"><a href="#define-the-dialog-actions">Define
            the dialog actions</a></div>
        <div style="margin-left: 3em;"><a href="#closing-dialog">Closing dialog
          </a></div>
        <div style="margin-left: 3em;"><a href="#plain-view-instead-of-dialog">Plain
            view instead of dialog</a></div>
        <div style="margin-left: 2em;"><a href="#junit-tests">JUnit tests</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-detail-mode-action">Testing
            the detail mode action</a></div>
        <div style="margin-left: 3em;"><a href="#finding-an-entity-for-testing-using-list-mode-and-jpa">Finding
            an entity for testing using list mode and JPA</a></div>
        <div style="margin-left: 3em;"><a href="#testing-hiding-of-the-action">Testing
            hiding of the action</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-list-mode-action">Testing
            the list mode action</a></div>
        <div style="margin-left: 3em;"><a href="#asserting-test-data">Asserting
            test data</a></div>
        <div style="margin-left: 3em;"><a href="#testing-exceptional-cases">Testing
            exceptional cases</a></div>
        <div style="margin-left: 2em;"><a href="#summary">Summary</a></div>
      </div>
      In previous lessons you learned how to add your own actions. However this
      is not enough to fully customize the behavior of your application, because
      the generated user interface, in concrete the user interface for
      references and collections, has a standard behavior that sometimes is not
      the most convenient. <br>
      Fortunately, OpenXava provides many ways to customize the behavior for
      references and collections. In this lesson you will learn how to do some
      of these customizations, and how this adds value to your application.
      <h2>Refining reference behavior</h2>
      You might have noticed that the <i>Order</i> module has a little slip:
      the user can add any invoice he wants to the current order, even if the
      invoice customer was different. This is not acceptable. Let's fix it.
      <h3>Validation is good, but not enough</h3>
      The user can only associate an invoice to an order if both, invoice and
      order, belong to the same customer. This is specific business logic of
      your application, so the standard OpenXava behavior does not solve it. The
      next image shows as a validation error is produced when customer of
      invoice is incorrect </div>
    <img src="files/references-collections_en010.png" alt="references-collections_en010"
      title="references-collections_en010">
    <div class="wiki" style="display: block;"> Since this is business logic we
      are going to put it in the model layer, that is, in the entities. We'll do
      it adding a validation. Thus you'll get the effect of the above figure.
      You already know how to add this validation to your <i>Order </i>entity.
      It's just adding a method annotated with <i>@AssertTrue</i>:<br>
      <pre><code class="java">public class Order {

    ...

    // This method must return true for this order to be valid
    @AssertTrue(message="customer_order_invoice_must_match") 
    private boolean isInvoiceCustomerMatches() {
    	return invoice == null || // invoice is optional
    		invoice.getCustomer().getNumber() == getCustomer().getNumber();
    }

}
</code></pre>Also you have to add the message to <i>i18n/Invoicing-messages_en.properties</i>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="properties">customer_order_invoice_must_match=The customer of the invoice and the order must match
</code></pre> </div>
    <div class="wiki" style="display: block;"> Here we verify that the customer
      of the invoice is the same as the customer of this order. This is enough
      to preserve the data integrity, but this validation alone is a poor option
      from the user viewpoint.
      <h3>Refining action for searching reference with list</h3>
      Although validation prevents the user from assigning an incorrect invoice
      to an order, he has a hard time trying to find a correct invoice. Because
      when the user clicks to search an invoice, all existing invoices are
      shown. We are going to improve this for showing only the invoices from the
      customer of the current displayed order, in this way:</div>
    <img src="files/references-collections_en020.png" alt="references-collections_en020.png"
      title="references-collections_en020.png"><br>
    <div class="wiki" style="display: block;"> For defining our own search
      action for the invoice reference we will use the <i>@SearchAction</i>
      annotation. Here you have the needed modification in <i>Order</i>
      class:&nbsp;
      <pre><code class="java">public class Order extends CommercialDocument {

    @ManyToOne
    @ReferenceView("NoCustomerNoOrders")
    @OnChange(ShowHideCreateInvoiceAction.class)
    @SearchAction("Order.searchInvoice") // To define our own action to search invoices
    Invoice invoice;

    ...
	
}
</code></pre> In this simple way we define the action to execute when the user
      clicks on the flashlight button to search an invoice. The argument used
      for <i> @SearchAction</i>, <i>Order.searchInvoice</i>, is the qualified
      name of the action, that is the action <i>searchInvoice</i> of the
      controller <i>Order</i> as defined in <i> controllers.xml</i> file. Now
      we have to edit <i>controllers.xml</i> to add the definition of our new
      action:
      <pre><code class="xml">&lt;controller name="Order"&gt;

    ...
	
    &lt;action name="searchInvoice"
        class="com.yourcompany.invoicing.actions.SearchInvoiceFromOrderAction"
        hidden="true" icon="magnify"/&gt;
        &lt;!--
        hidden="true" : Because we don't want the action to be shown in module button bar
        icon="magnify" : The same icon as for the standard search action
        --&gt;
	
&lt;/controller&gt;
</code></pre> Our action extends from <i>ReferenceSearchAction</i> as shown in
      the next code:
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import org.openxava.actions.*; // To use ReferenceSearchAction

public class SearchInvoiceFromOrderAction
    extends ReferenceSearchAction { // Standard logic for searching a reference

    public void execute() throws Exception {
        int customerNumber =
            getView().getValueInt("customer.number"); // Reads from the view the
                                         // customer number of the current order
        super.execute(); // It executes the standard logic that shows a dialog
        if (customerNumber &gt; 0) { // If there is customer we use it to filter
            getTab().setBaseCondition("${customer.number} = " + customerNumber);
        }
    }
}
</code></pre> Note how we use <i>getTab().setBaseCondition()</i> to establish a
      condition for the list to choose the reference. That is, from a <i>
        ReferenceSearchAction</i> you can use <i>getTab()</i> to manipulate the
      way the search list behaves. <br>
      If there is no customer we don't add any condition so all the invoices
      will be shown, this is the case when the user chooses the invoice before
      choosing the customer.
      <h3>Searching the reference typing in fields</h3>
      The list for choosing a reference already works fine. However, we want to
      give the user the possibility to choose the invoice without the list, by
      just typing the year and number. Very useful if the user already know
      which invoice he wants. OpenXava provides this functionality by default.
      If the <i>@Id</i> fields are displayed in the reference they are used for
      searching, otherwise OpenXava uses the first displayed field to search.
      This is not convenient in our case, because the first displayed field is
      the year, and searching an invoice only by year is not very precise. The
      following image shows the default behavior and a more convenient
      alternative:<br>
      <img src="files/references-collections_en030.png" alt="references-collections_en030.png"
        title="references-collections_en030.png"><br>
      Fortunately it's easy to indicate which fields we want to use to search
      from a user perspective. This is done by means of <i>@SearchKey</i>
      annotation. Just edit the <i>CommercialDocument</i> class (remember, the
      parent of <i>Order</i> and <i> Invoice</i>) and add that annotation to
      the <i>year</i> and <i>number</i> properties:
      <pre><code class="java">abstract public class CommercialDocument extends Deletable {

    @SearchKey // Add this annotation here
    @Column(length=4)
    @DefaultValueCalculator(CurrentYearCalculator.class) 
    int year;

    @SearchKey // Add this annotation here 
    @Column(length=6)
    @ReadOnly
    int number;
	
    ...
	
}
</code></pre> In this way when the user searches an order or invoice from a
      reference he must type the year and the number, and the corresponding
      entity will be retrieved from database and will populate the user
      interface. <br>
      Now it's easy for the user to choose an invoice for the order without
      using the searching list, just by typing year and number.
      <h3>Refining action for searching reference typing key</h3>
      Now that retrieving an invoice by the year and number is usable, we want
      to refine it in order to help our user to do his work more efficiently.
      For example, it would be useful that if the user has not chosen a customer
      for the order yet and he chooses an invoice, the customer of that invoice
      will be assigned to the current order automatically. The following image
      visualizes the wanted behavior:<br>
      <img src="files/references-collections_en040.png" alt="references-collections_en040.png"
        title="references-collections_en040.png"><br>
      On the other hand, if the user already has selected the customer for the
      order, if he is not the same in the invoice, it will be rejected and a
      message error displayed, just in this way:</div>
    <img src="files/references-collections_en050.png" alt="references-collections_en050.png"
      title="references-collections_en050.png"><br>
    <div class="wiki" style="display: block;"> For defining this special
      behavior we have to add an <i>@OnChangeSearch</i> annotation in the the <i>invoice</i>
      reference of <i>Order</i>. <i>@OnChangeSearch</i> allows you to define
      your own action to do the search of the reference when its key changes in
      the user interface. You can see the modified reference here:
      <pre><code class="java">public class Order extends CommercialDocument {
 
    @ManyToOne
    @ReferenceView("NoCustomerNoOrders") 
    @OnChange(ShowHideCreateInvoiceAction.class)
    @OnChangeSearch(OnChangeSearchInvoiceAction.class) // Add this annotation
    @SearchAction("Order.searchInvoice")
    Invoice invoice;
	
    ...
	
}	
</code></pre> From now on when the user types a new year and number for the
      invoice, the logic of <i>OnChangeSearchInvoiceAction</i> will be
      executed. In this action you have to read the invoice data from database
      and update the user interface. This is the action code:
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import java.util.*;
import org.openxava.actions.*; // To use OnChangeSearchAction
import org.openxava.model.*;
import org.openxava.view.*;
import com.yourcompany.invoicing.model.*;

public class OnChangeSearchInvoiceAction 
    extends OnChangeSearchAction { // Standard logic for searching a reference when
                                   // the key values change in the user interface (1)
    public void execute() throws Exception {
        super.execute(); // It executes the standard logic (2)
        Map keyValues = getView()// getView() here is the reference view, not the main one (3)
            .getKeyValuesWithValue();
        if (keyValues.isEmpty()) return; // If key is empty no additional logic is executed
        Invoice invoice = (Invoice) // We search the Invoice entity from the typed key (4)
            MapFacade.findEntity(getView().getModelName(), keyValues);
        View customerView = getView().getRoot().getSubview("customer"); // (5)
        int customerNumber = customerView.getValueInt("number");
        if (customerNumber == 0) { // If there is no customer we fill it (6)
            customerView.setValue("number", invoice.getCustomer().getNumber());
            customerView.refresh();
        } 
        else { // If there is already customer we verify that he matches the invoice customer (7)
            if (customerNumber != invoice.getCustomer().getNumber()) {
                addError("invoice_customer_not_match", 
                    invoice.getCustomer().getNumber(), invoice, customerNumber);
                getView().clear();
            }
        }
    }
}	
</code></pre> Given the action extends from <i>OnChangeSearchAction</i> (1) and
      we use <i>super.execute() </i>(2) it behaves just in the standard way,
      that is, when the user types a year and number the invoice data is
      retrieved and fills the user interface. Afterwards, we use <i>getView()</i>
      (3) to obtain the key of the displayed invoice to find the corresponding
      entity using <i>MapFacade</i> (4). From inside an <i>OnChangeSearchAction</i>
      <i>getView()</i> returns the subview of the reference, and not the global
      view. Therefore, in this case <i>getView()</i> is the view of the invoice
      reference. This allows you to create more reusable <i>@OnChangeSearch</i>
      actions. Thus you have to write <i>getView().getRoot().getSubview(“customer”)</i>
      (5) to access to the customer view. <br>
      To implement the behavior visualized in the previous image, the action
      asks if there is no customer (<i>customberNumber == 0</i>) (6). If this is
      the case it fills the customer from the customer of the invoice. Otherwise
      it implements the logic from previous image verifying that the customer of
      the current order matches the customer of the retrieved invoice. <br>
      The last remaining detail is the message text. Add the next entry to the <i>Invoicing-messages_en.properties</i>
      file of <i>i18n</i> folder.
      <pre><code class="properties">invoice_customer_not_match=Customer Nº {0} of invoice {1} does not match with customer Nº {2} of the current order
</code></pre> One interesting thing about <i>@OnChangeSearch</i> is that it is
      also executed when the invoice is chosen from a list, because in this case
      the year and number of the invoice also changes. Hence, this is a
      centralized place to refine the logic for retrieving the reference and
      populating the view.
      <h2>Refining collection behavior</h2>
      We can refine collections in the same way we have refined references. This
      is very useful, because it allows us to improve the current behavior of
      the <i>Invoice </i>module. The user can only add an order to an invoice
      if the invoice and the orders belongs to the same customer. Moreover, the
      order must be delivered and must not have an invoice yet.
      <h3>Refining the list for adding elements to a collection</h3>
      Currently when the user tries to add orders to an invoice all the orders
      are available. We are going to improve this for showing only the orders
      from the customer of the invoice, delivered and with not invoice yet, just
      as shown: <br>
      <img src="files/references-collections_en60.png" alt="references-collections_en60.png"
        title="references-collections_en60.png"><br>
      We will use the <i>@AddAction</i> annotation for defining our own action
      to show the list for adding orders. The following code shows the needed
      modification in <i>Invoice</i> class.
      <pre><code class="java">public class Invoice extends CommercialDocument {

    @OneToMany(mappedBy="invoice")
    @CollectionView("NoCustomerNoInvoice")
    @AddAction("Invoice.addOrders") // To define our own action to add orders
    Collection&lt;Order&gt; orders;

    ...
	
}
</code></pre> In this simple way we define the action to execute when the user
      clicks on the button to add orders. The argument used for <i>@AddAction</i>,
      <i>Invoice.addOrders</i>, is the qualified name of the action, that is the
      action <i>addOrders</i> of the controller <i>Invoice</i> as defined in <i>
        controllers.xml</i> file. <br>
      Now we have to edit <i>controllers.xml</i> to add the <i>Invoice</i>
      controller (it does not exist yet) definition with our new action:
      <pre><code class="xml">&lt;controller name="Invoice"&gt;
    &lt;extends controller="Invoicing"/&gt;

    &lt;action name="addOrders"
        class="com.yourcompany.invoicing.actions.GoAddOrdersToInvoiceAction"
        hidden="true" icon="table-row-plus-after"/&gt;
        &lt;!--
        hidden="true" : Because we don't want the action to be shown in module button bar
        icon="table-row-plus-after" : The same icon as for the standard action
        --&gt;

&lt;/controller&gt;
</code></pre>This is the action code:
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import org.openxava.actions.*; // To use GoAddElementsToCollectionAction

public class GoAddOrdersToInvoiceAction
    extends GoAddElementsToCollectionAction { // Standard logic to go to
                                              // adding collection elements list
    public void execute() throws Exception {
        super.execute(); // It executes the standard logic, that shows a dialog
        int customerNumber =
            getPreviousView() // getPreviousView() is the main view (we are in a dialog)
                .getValueInt("customer.number"); // Reads the customer number
                                                 // of the current invoice from the view
        getTab().setBaseCondition( // The condition of the orders list to add
            "${customer.number} = " + customerNumber +
            " and ${delivered} = true and ${invoice} is null"
        );
    }
}
</code></pre> Note how we use <i>getTab().setBaseCondition()</i> to establish a
      condition for the list to choose the entities to add. That is, from a <i>
        GoAddElementsToCollectionAction</i> you can use <i>getTab()</i> to
      manipulate the way the list behaves.
      <h3>Refining the action to add elements to a collection</h3>
      A useful improvement for the orders collection would be that when the user
      adds orders to the current invoice, the detail lines of those orders will
      be copied automatically to the invoice.<br>
      We cannot use the <i>@AddAction</i> for this, because it is the action to
      show the list to add elements to the collection. But this is not the
      action that adds the elements. <br>
      Let's learn how to define the action that actually adds the elements: <br>
      <img src="files/references-collections_en70.png" alt="references-collections_en70.png"
        title="references-collections_en70.png"><br>
      Unfortunately, there is not an annotation to directly define this 'Add'
      action. However, that is not a very difficult task, we only have to refine
      the <i>@AddAction</i> instructing it to show our own controller, and in
      this controller we can put the actions we want. Given we already have
      defined our <i>@AddAction</i> in the previous section we only have to add
      a new method to the already existing <i>GoAddOrdersToInvoiceAction</i>
      class. Add the next <i>getNextController()</i> method to your action:
      <pre><code class="java">public class GoAddOrdersToInvoiceAction ... {

    ...

    public String getNextController() { // We add this method
        return "AddOrdersToInvoice"; // The controller with the available actions
    }                                // in the list of orders to add
}
</code></pre> By default the actions in the list of entities to add (the 'Add'
      and 'Cancel' buttons) are from the standard OpenXava controller <i>AddToCollection</i>.
      Overwriting <i>getNextController()</i> in our action allows us to define
      our own controller instead. Add the next definition in <i>controllers.xml</i>
      for our custom controller for adding elements:
      <pre><code class="xml">&lt;controller name="AddOrdersToInvoice"&gt;
    &lt;extends controller="AddToCollection" /&gt; &lt;!-- Extends from the standard controller --&gt;
	
    &lt;!-- Overwrites the action to add --&gt;
    &lt;action name="add"
        class="com.yourcompany.invoicing.actions.AddOrdersToInvoiceAction" /&gt;
		
&lt;/controller&gt;
</code></pre> In this way the action to add orders to the invoice is <i>AddOrdersToInvoiceAction</i>.
      Remember that the goal of our action is to add the orders to the invoice
      in the usual way, but also to copy the detail lines from those orders to
      the invoice. This is the code of the action:<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import java.rmi.*;
import java.util.*;
import javax.ejb.*;
import org.openxava.actions.*; // To use AddElementsToCollectionAction
import org.openxava.model.*;
import org.openxava.util.*;
import org.openxava.validators.*;
import com.yourcompany.invoicing.model.*;

public class AddOrdersToInvoiceAction
    extends AddElementsToCollectionAction { // Standard logic for adding
                                            // collection elements
    public void execute() throws Exception {
        super.execute(); // We use the standard logic “as is”
        getView().refresh(); // To display fresh data, including recalculated
    }                        // amounts, which depend on detail lines

    protected void associateEntity(Map keyValues) // The method called to associate
        throws ValidationException, // each entity to the main one, in this case to
            XavaException, ObjectNotFoundException,// associate each order to the invoice
            FinderException, RemoteException
    {
        super.associateEntity(keyValues); // It executes the standard logic (1)
        Order order = (Order) MapFacade.findEntity("Order", keyValues); // (2)
        order.copyDetailsToInvoice(); // Delegates the main work to the entity (3)
    }
}
</code></pre> We overwrite the <i>execute()</i> method only to refresh the view
      after the process. Really, we want to refine the logic for associating an
      order to the invoice. The way to do this is overwriting the <i>associateEntity()</i>
      method. The logic here is simple, after executing the standard logic (1)
      we search the corresponding <i>Order</i> entity and then call the <i>copyDetailsToInvoice()</i>
      in that <i>Order</i>. Luckily we already have a method to copy details
      from an <i>Order</i> to the specified <i>Invoice</i>, we just call this
      method. </div>
    <div class="wiki" style="display: block;">Now you only have to create a new
      invoice, choose a customer and add orders. It is even easier than using
      the list mode of <i>Order</i> module because from <i>Invoice</i> module
      only the suitable orders for the customer are shown.
      <h2>JUnit tests</h2>
      We still are in the healthy habit of doing some application code, then
      some testing code. And now it's time to write the test code for the new
      feature we added in this lesson.
      <h3>Adapting <i>OrderTest</i></h3>
      If you run <i>OrderTest</i> right now it does not pass. This is because
      our test code relies in some details that have changed. Therefore, we have
      to modify the current test code. Edit the <i>testSetInvoice()</i> method
      of <i> OrderTest</i> and apply the next changes:
      <pre><code class="java">public void testSetInvoice() throws Exception {

    ...
	
    assertValue("invoice.number", "");
    assertValue("invoice.year", "");
    // execute("Reference.search", // The standard action for invoice searching
    //    "keyProperty=invoice.year"); // is no longer used
    execute("Order.searchInvoice", // Instead we use our custom action (1)
        "keyProperty=invoice.number");
    execute("List.orderBy", "property=number");

    ...
	
    // Restore values
    setValue("delivered", "false");
    setValue("invoice.year", ""); // Now we need to type a year
    setValue("invoice.number", ""); // and a number to search the invoice (2)
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Remember that we annotated the invoice reference in <i>Order </i>with
      <i>@SearchAction("Order.searchInvoice")</i>, so we have to modify the test
      to call <i>Order.searchInvoice</i> (1) instead of <i>Reference.search</i>.
      Also we added <i>@SearchKey</i> to year and number of <i>CommercialDocument</i>,
      therefore our test has to indicate both year and number to get (or clear
      in this case) an invoice (2). Because of this last point we also have to
      modify <i>testCreateInvoiceFromOrder()</i> of <i>OrderTest</i>:
      <pre><code class="java">public void testCreateInvoiceFromOrder() throws Exception {

    ...

    // Restoring the order for running the test the next time
    setValue("invoice.year", ""); // Now we need to type a year
    setValue("invoice.number", ""); // and a number to search the invoice (2)
    assertValue("invoice.number", "");
    assertCollectionRowCount("invoice.details", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> After these changes the <i>OrderTest</i> must pass. However, we
      still have to add the testing of the new functionality of <i>Order</i>
      module.
      <h3>Testing the <i>@SearchAction</i></h3>
      We have used <i>@SearchAction</i> in the <i>invoice </i>reference of <i>Order</i>
      for showing in the search list only the invoices from the customer of the
      current order. Add the next method to <i>OrderTest</i> to test of this
      functionality:
      <pre><code class="java">public void testSearchInvoiceFromOrder() throws Exception {
    execute("CRUD.new");
    setValue("customer.number", "1"); // If the customer is 1...
    execute("Sections.change", "activeSection=1");
    execute("Order.searchInvoice", // ...when the user clicks to choose an invoice...
        "keyProperty=invoice.number");
    assertCustomerInAllRows("1"); // ...only the invoices of customer 1 are shown
    execute("ReferenceSearch.cancel");
    execute("Sections.change", "activeSection=0");
    setValue("customer.number", "2"); // And if the customer is 2...
    execute("Sections.change", "activeSection=1");
    execute("Order.searchInvoice", // ...when the user clicks to choose an invoice...
        "keyProperty=invoice.number");
    assertCustomerInList("2"); // ...only the invoices of customer 2 are shown
}
</code></pre> The trickier part is to assert the invoices list, this is the work
      for <i>assertCustomerInAllRows()</i> in <i>OrderTest</i>:
      <pre><code class="java">private void assertCustomerInAllRows(String customerNumber) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) { // A loop over all rows
        if (!customerNumber.equals(getValueInList(i, "customer.number"))) {
            fail("Customer in row " + i + // If the customer is not the expected one it fails
                " is not " + customerNumber);
        }
    }
}
</code></pre> It consists in a loop over all rows verifying the customer number.
      <h3>Testing the <i>@OnChangeSearch</i></h3>
      We used <i>@OnChangeSearch</i> in the <i> invoice</i> reference of <i>Order</i>
      for assigning automatically the customer of the chosen invoice to the
      current order when the order has no customer yet, or for verifying that
      the invoice and order customer matches, if the order already has a
      customer. This is the test method in <i>OrderTest</i>:
      <pre><code class="java">public void testOnChangeInvoice() throws Exception {
    execute("CRUD.new"); // We are creating a new order
    assertValue("customer.number", ""); // so it has no customer yet
    execute("Sections.change", "activeSection=1");
    execute("Order.searchInvoice", // Looks for the invoice using a list
        "keyProperty=invoice.number");
		
    execute("List.orderBy", "property=customer.number"); // It orders by customer
    String customer1Number = getValueInList(0, "customer.number"); // Memorizes..
    String invoiceYear1 = getValueInList(0, "year"); // ..the data of the...
    String invoiceNumber1 = getValueInList(0, "number"); // ...first invoice
    execute("List.orderBy", "property=customer.number"); // It orders by customer
    String customer2Number = getValueInList(0, "customer.number"); // Memorizes..
    String customer2Name = getValueInList(0, "customer.name"); // ..the data of
                                                           // ...the last invoice
    assertNotEquals("Must be invoices of different customer",
    customer1Number, customer2Number); // The 2 memorized invoices aren't the same
	
    execute("ReferenceSearch.choose","row=0");// The invoice is chosen using the list (1)
    execute("Sections.change", "activeSection=0");
    assertValue("customer.number", customer2Number); // The customer data is
    assertValue("customer.name", customer2Name); // filled automatically (2)
    execute("Sections.change", "activeSection=1");
    setValue("invoice.year", invoiceYear1); // We try to put an invoice of another...
    setValue("invoice.number", invoiceNumber1); // ...customer (3)
	
    assertError("Customer Nº " + customer1Number + " of invoice " + // It shows
        invoiceYear1 + "/" + invoiceNumber1 + // an error message... (4)
        " does not match with Customer Nº " +
        customer2Number + " of the current order");
		
    assertValue("invoice.year", ""); // ...and resets the invoice data (5)
    assertValue("invoice.number", "");
    assertValue("invoice.date", "");
}
</code></pre> Here we test that our on-change action fills the customer data (3)
      on choosing an invoice (2), and that if the customer is already set, an
      error message is shown (4) and the invoice is cleared in the view (5).
      Note how the first time we use the list (1) to choose the invoice and the
      second time we do it typing the year and number (3).
      <h3>Adapting <i>InvoiceTest</i></h3>
      As in the case of <i>OrderTest</i>, <i>InvoiceTest</i> also fails to
      pass. You have to do a little adjustments so it works fine. Edit <i>testAddOrders()</i>
      of <i> InvoiceTest</i> and apply the next changes:
      <pre><code class="java">public void testAddOrders() throws Exception {
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("Mode.detailAndFirst");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("orders", 0);
    // execute("Collection.add", // The standard action for adding orders is no longer used
    execute("Invoice.addOrders", // Instead we use our custom action
        "viewObject=xava_view_section1_orders");
    // checkFirstOrderWithDeliveredEquals("Delivered"); // Now all orders in the list are
    // checkFirstOrderWithDeliveredEquals(""); // delivered so it makes no sense
    // execute("AddToCollection.add"); // Instead of the standard action...
    execute("AddOrdersToInvoice.add", "row=0"); // ...now we have our custom one
    // assertError("ERROR! 1 element(s) NOT added to Orders of Invoice"); // It is
                             // impossible because the use cannot chose incorrect orders
    assertMessage("1 element(s) added to Orders of Invoice");
    assertCollectionRowCount("orders", 1);
    checkRowCollection("orders", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_orders");
    assertCollectionRowCount("orders", 0);
}
</code></pre> The <i>checkFirstOrderWithDeliveredEquals()</i> method is no
      longer necessary, therefore we can remove it from <i>InvoiceTest</i>:
      <pre><code class="java">// Remove checkFirstOrderWithDeliveredEquals() from InvoiceTest
// private void checkFirstOrderWithDeliveredEquals(String value)
// throws Exception { ... }
</code></pre> After these changes the <i>InvoiceTest</i> must pass. However, we
      still have to add the testing of the new functionality of <i>Invoice</i>
      module.
      <h3>Testing the <i>@AddAction</i></h3>
      In this lesson we annotated the <i>orders</i> collection of <i>Invoice</i>
      with <i>@AddAction</i> to refine the list of orders to be added to the
      collection. In this way only delivered orders of the customer of the
      current invoice and with no invoice yet are shown. We are going to test
      this, and at the same time, we'll learn how to refactor the existing code
      in order to reuse it. <br>
      First, we want to verify that the list to add orders only contains orders
      of the current customer. The next code shows the changes in <i>testAddOrders()</i>
      of <i>InvoiceTest</i> to accomplish this.
      <pre><code class="java">public void testAddOrders() throws Exception {
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("Mode.detailAndFirst");
    String customerNumber = getValue("customer.number"); // We take note of the
    execute("Sections.change", "activeSection=1");   // customer of the invoice
    assertCollectionRowCount("orders", 0);
    execute("Invoice.addOrders", 
	    "viewObject=xava_view_section1_orders");
    assertCustomerInList(customerNumber); // We assert all customers in list
                                          // matches the invoice customer
    ...

}
</code></pre> Now we have to write the <i>assertCustomerInList()</i> method.
      But, wait a minute, we already have written this method in <i>OrderTest</i>.
      We are in <i>InvoiceTest</i> so we cannot call this method, fortunately
      both <i>InvoiceTest</i> and <i>OrderTest</i> extend the <i>CommercialDocumentTest</i>,
      therefore we only need to pull up the method. To do it copy the <i>assertCustomerInList()</i>
      method from <i>OrderTest</i> and paste it in <i>CommercialDocumentTest</i>,
      changing <i>private</i> to <i>protected</i>, just as shown:
      <pre><code class="java">abstract public class CommercialDocumentTest extends ModuleTestBase {

    protected void // We change private to protected
        assertCustomerInList(String customerNumber) throws Exception {

        ...
		
    }

    ...
	
}
</code></pre> TMP ME QUEDÉ POR AQUÍ Now you can remove the
      assertCustomerInList() method from OrderTest (listing 9.27).
      <pre>Listing 9.27 assertCustomerInList() removed from OrderTest
public class OrderTest extends CommercialDocumentTest {
private void assertCustomerInList(String customerNumber)
throws Exception { ... }
...
}
</pre> After these changes the testAddOrders() method compiles and works. We not
      only want to test if the orders in list are from the correct customer, but
      also that they are delivered. The first primary impulse is to copy and
      paste assertCustomerInList() for creating an assertDeliveredInList()
      method. However, we resist the temptation, instead we are going to create
      a reusable method. First, we copy and paste assertCustomerInList() as
      assertValueForAllRows(). Listing 9.28 shows these two methods in
      CommercialDocumentTest.
      <pre>Listing 9.28 Creating assertValueForAllRows() from assertCustomerInList()
protected void assertCustomerInList(String customerNumber) throws Exception {
assertListNotEmpty();
int c = getListRowCount();
for (int i=0; i&lt;c; i++) {
if (!customerNumber.equals(
getValueInList(i, "customer.number"))) // We ask “ad hoc” for customer
{
fail("Customer in row " + i + " is not of customer "
+ customerNumber);
}
}
}
protected void assertValueForAllRows(int column, String value)
throws Exception
{
assertListNotEmpty();
int c = getListRowCount();
for (int i=0; i&lt;c; i++) {
if (!value.equals(
{

}

}

}

getValueInList(i, column)))

// We ask for the column sent as parameter

fail("Column " + column + " in row " + i + " is not " + value);
</pre> You can see how with a very slight modification we have turned
      assertCustomerInList() in a generic method to ask for the value of any
      column, not just customer number. Now we have to remove the redundant
      code, you can either remove assertCustomerInList() or reimplementing it
      using the new one. Listing 9.29 shows the later option.
      <pre>Listing 9.29 Reimplementing assertCustomerInList() calling to the new method
protected void assertCustomerInList(String customerNumber) throws Exception {
assertValueForAllRows(3, customerNumber); // Customer number is in column 3
}
</pre> Let's use assertValueForAllRows() to assert the orders list contains only
      delivered orders. Listing 9.30 shows the needed modification in
      testAddOrders() of InvoiceTest.
      <pre>Listing 9.30 Asserting that all orders in list are delivered
public void testAddOrders() throws Exception {
assertListNotEmpty();
execute("List.orderBy", "property=number");
execute("Mode.detailAndFirst");
String customerNumber = getValue("customer.number");
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes"); // All the cells of column 5 (delivered) contain 'Yes'
...
}
</pre> Moreover, we want to test that only orders with no invoice are shown in
      the list. A simple way to do it is verifying that after adding an order to
      the current invoice, the list of orders has an entry fewer. Listing 9.31
      shows the needed changes to testAddOrders() to do this testing.
      <pre>Listing 9.31 Testing that the added orders cannot be added again
public void testAddOrders() throws Exception {
...
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
int ordersRowCount = getListRowCount();

// We take note of orders count
execute("AddOrdersToInvoice.add", "row=0"); // when the list is shown
assertMessage("1 element(s) added to Orders of Invoice");
assertCollectionRowCount("orders", 1); // An order was added
execute("Invoice.addOrders", // We show the orders list again
"viewObject=xava_view_section1_orders");
assertListRowCount(ordersRowCount - 1); // Now we have an order fewer in the list
execute("AddToCollection.cancel");
...
}
</pre> With the code of this section we have tested the @NewAction of orders
      collection, and at the same time we have seen how it's not needed to
      develop generic code from start, because it's not difficult to convert the
      concrete code into generic on demand.
      <h3>Testing the action to add elements to the collection</h3>
      In section 9.2.3 we learned how the refine the action that adds orders to
      the invoice, now it's the moment of testing it. Remember that this action
      copies the lines from selected orders to the current invoice. Listing 9.32
      shows the changes for testing of our custom action to add orders.
      <pre>Listing 9.32 When an order is added its lines are added to the invoice
public void testAddOrders() throws Exception {
...
String customerNumber = getValue("customer.number");
deleteDetails(); // Deletes the detail lines if any (1)
assertCollectionRowCount("details", 0); // Now the invoice has no details
assertValue("baseAmount", "0.00"); // With no details base amount is 0
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders", // When we show the order list (2) ...
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
String firstOrderBaseAmount = getValueInList(0, 8); // ...we take note of base
int ordersRowCount = getListRowCount();
// amount of first order in the list (3)
...
assertCollectionRowCount("orders", 1);
execute("Sections.change", "activeSection=0");
assertCollectionNotEmpty("details"); // There are details, they have been copied (4)
assertValue("baseAmount", firstOrderBaseAmount); // The base amount of the
execute("Sections.change", "activeSection=1"); // invoice matches with the one
// of the recently added order (5)
...
}
</pre> We remove the detail lines from the invoice (1), afterwards we add an
      order (2), taking note of its base amount (3), then we verify that current
      invoice has details (4) and its base amount is the same of the added order
      (5). All that remains is the deleteDetails() method, shown in listing
      9.33.
      <pre>Listing 9.33 Deletes all the details of the displayed invoice
private void deleteDetails() throws Exception {
int c = getCollectionRowCount("details");
for (int i=0; i&lt;c; i++) { // A loop over all rows
checkRowCollection("details", i); // Checks each row
}
execute("Collection.removeSelected", // Removes the checked rows
"viewObject=xava_view_section0_details");
}
</pre> It selects all the rows of the details collection and clicks on the
      'Remove selected' button. The testAddOrders() method is finished. You can
      see its definitive code in listing 9.34.
      <pre>Listing 9.34 Definitive code for testAddOrders() of InvoiceTest
public void testAddOrders() throws Exception {
assertListNotEmpty();
execute("List.orderBy", "property=number");
execute("Mode.detailAndFirst");
String customerNumber = getValue("customer.number");
deleteDetails();
assertCollectionRowCount("details", 0);
assertValue("baseAmount", "0.00");
execute("Sections.change", "activeSection=1");
assertCollectionRowCount("orders", 0);
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertCustomerInList(customerNumber);
assertValueForAllRows(5, "Yes");
String firstOrderBaseAmount = getValueInList(0, 8);
int ordersRowCount = getListRowCount();
execute("AddOrdersToInvoice.add", "row=0");
assertMessage("1 element(s) added to Orders of Invoice");
assertCollectionRowCount("orders", 1);
execute("Sections.change", "activeSection=0");
assertCollectionNotEmpty("details");
assertValue("baseAmount", firstOrderBaseAmount);
execute("Sections.change", "activeSection=1");
execute("Invoice.addOrders",
"viewObject=xava_view_section1_orders");
assertListRowCount(ordersRowCount - 1);
execute("AddToCollection.cancel");
checkRowCollection("orders", 0);
execute("Collection.removeSelected",
"viewObject=xava_view_section1_orders");
assertCollectionRowCount("orders", 0);
}
</pre> We have finished the test code. Now it's time to execute all the tests
      for your project. They must be green.
      <h2>Summary</h2>
      This lesson has shown you how to refine the standard behavior of
      references and collections in order for your application to fit the users
      needs. Here you only have seen some illustrative examples, but OpenXava
      provides many more possibilities for refining collections and references,
      such as the next annotations: @ReferenceView, @ReadOnly, @NoFrame,
      @NoCreate, @NoModify, @NoSearch, @AsEmbedded, @SearchAction,
      @DescriptionsList, @LabelFormat, @Action, @OnChange, @OnChangeSearch,
      @Editor, @CollectionView, @EditOnly, @ListProperties, @RowStyle,
      @EditAction, @ViewAction, @NewAction, @SaveAction, @HideDetailAction,
      @RemoveAction, @RemoveSelectedAction, @ListAction, @DetailAction and
      @OnSelectElementAction. <br>
      And if that wasn't enough you always have the option of defining your own
      editor for references or collections. Editors allows you to create a
      custom user interface component for displaying and editing the reference
      or collection. <br>
      This flexibility allows you to use automatic user interfaces for
      practically any possible case in real life business applications. <strong><a
          class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-8-business-logic-behavior_en.zip/download"
          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"
          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine?
        <a class="wiki_link" href="references-collections_en.html">Go to Lesson
          9</a></strong> </div>
  </body>
</html>
