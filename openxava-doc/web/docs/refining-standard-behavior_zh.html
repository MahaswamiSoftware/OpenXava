<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title> Lesson 24: Refining the standard behavior - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Lesson 24: Refining the standard behavior"></a> <span
          id="breadcrumbs"> <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava </a> </span> / <a
            href="index_zh.html">文档</a> / </span>第二十四章：改进标准行为</h1>
      <strong>课程：</strong><a class="wiki_link" href="getting-started_zh.html">1. 入门教学</a> | <a
        class="wiki_link" href="basic-domain-model1_zh.html">2. 基本域模型（上）</a> | <a
        class="wiki_link" href="basic-domain-model2_zh.html">3. 基本域模型（下）</a> | <a
        class="wiki_link" href="refining-user-interface_zh.html">4. 优化用户界面</a> | <a
        class="wiki_link" href="agile-development_zh.html">5. 敏捷开发</a> | <a
        class="wiki_link" href="mapped-superclass-inheritance_zh.html">6. 映射式超类继承</a> | <a
        class="wiki_link" href="entity-inheritance_zh.html">7. 实体继承</a> | <a
        class="wiki_link" href="view-inheritance_zh.html">8. 视图继承（View）</a> | <a
        class="wiki_link" href="java-properties_zh.html">9. Java 属性</a> | <a
        class="wiki_link" href="calculated-properties_zh.html">10. 计算属性</a> | <a
        class="wiki_link" href="defaultvaluecalculator-in-collections_zh.html">11. 用在集合的 @DefaultValueCalculator</a><strong> </strong> | <a
        class="wiki_link" href="calculation-and-collections-total_zh.html">12. @Calculation 和集合总计</a> | <a
        class="wiki_link" href="defaultvaluecalculator-from-file_zh.html">13. 从外部文件的 @DefaultValueCalculator</a> | <a
        class="wiki_link" href="manual-schema-evolution_zh.html">14. 手动更改 schema</a> | <a
        class="wiki_link" href="multi-user-default-value-calculation_zh.html">15. 多用户时默认值的计算</a> | <a
        class="wiki_link" href="synchronize-persistent-and-computed-properties_zh.html">16. 同步持久属性和计算属性</a> | <a
        class="wiki_link" href="logic-from-database_zh.html">17. 从数据库中的逻辑</a> |<span
        style="color: #0000ee;"></span><span style="color: #0000ee;"> </span><a
        class="wiki_link" href="validating-with-entityvalidator_zh.html">18. 使用 @EntityValidator 进行验证</a> | <a
        class="wiki_link" href="validation-alternatives_zh.html">19. 验证替代方案</a> | <a
        class="wiki_link" href="validation-on-remove_zh.html">20. 删除时验证</a> |&nbsp;<a
        class="wiki_link" href="custom-bean-validation-annotation_zh.html"> 21. 自定义 Bean Validation 注解</a> | <a
        class="wiki_link" href="rest-service-call-from-validation_zh.html">22. 在验证中调用 REST 服务</a> | <a
        class="wiki_link" href="attributes-in-annotations_zh.html">23. 注解中的属性</a> | <strong>24. 改进标准行为 </strong> | <a
        class="wiki_link" href="business-logic-behavior_en.html">25. Behavior &amp; business logic</a> | <a
        class="wiki_link" href="references-collections_en.html">26. References &amp; collections</a> | <a
        class="wiki_link" href="philosophy_en.html">A. Architecture &amp; philosophy</a> | <a
        class="wiki_link" href="jpa_en.html">B. Java Persistence API</a> | <a
        class="wiki_link" href="annotations_en.html">C. Annotations</a> | <a
        class="wiki_link" href="testing_en.html">D. Automated testing</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">目录</h1>
        <div style="margin-left: 1em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior">第二十四章：改进标准行为</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Custom%20actions">自定义动作</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Custom%20actions-Typical%20controller">Typical 控制器</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Custom%20actions-Refining%20the%20controller%20for%20a%20module">优化一个模块的控制器</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Custom%20actions-Writing%20your%20own%20action">编写您的动作</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions">通用动作</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions-MapFacade%20for%20generic%20code">使用 MapFacade 的通用代码</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions-Changing%20the%20default%20controller%20for%20all%20modules">更改所有模块的默认控制器</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions-Come%20back%20to%20the%20model%20a%20little">先回到模型类</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions-Metadata%20for%20more%20generic%20code">使用元数据以达到更加通用的代码</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions-Call%20another%20action%20from%20an%20action">从动作调用另一个动作</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Generic%20actions-Refining%20the%20default%20search%20action">优化默认搜索的动作</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-List%20mode">列表模式</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-List%20mode-Filtering%20tabular%20data">筛选表格数据</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-List%20mode-List%20actions">列表的动作</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Reusing%20actions%20code">重复使动作的代码</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Reusing%20actions%20code-Using%20properties%20to%20create%20reusable%20actions">使用属性创建可重用的动作</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Reusing%20actions%20code-Custom%20modules">自定义模块</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Reusing%20actions%20code-Several%20tabular%20data%20definitions%20by%20entity">从实体定义表格的数据</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Reusing%20actions%20code-Reusable%20obsession">痴迷于重复使用</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-Summary">总结</a></div>
      </div>
      我希望您对 invoicing 应用程序的代码非常满意。它真的很简单，基本上是实体，一些简单的类来模拟您的问题。所有的业务逻辑都在这些实体中，OpenXava 会围绕著它们生成一个应用程序。<br>
      然而，人不能只靠业务逻辑生活。良好的行为也是很重要的。比起 OpenXava 自帶的標準行為，您或您的用户會渴望在應用程序中的添加某些不同的行為。有時為了用戶的良好體驗是必需優化某些行為地。<br>
      应用程序的行为是由控制器定义的。控制器只是动作的集合，动作是用户點击链接或按钮时所执行的代碼。您可以自定义控制器和動作，并将它们与模块或实体相关联，从而优化 OpenXava 的行为。<br>
      在本课，我们将改进标准控制器和動作，以便自定义 invoicing 应用程序的行为。<br>
      <h2 id="toc1"><a name="Lesson 7: Refining the standard behavior-Custom actions"></a>自定义动作</h2>
      默认情况下，一個 OpenXava 的模块在您管理實體上的功能非常全面，其中包括添加、修改、删除、搜索、生成 PDF 报告、导出到 Excel (CSV) 以及将数据导入实体。这些動作默认包含在 Typical 控制器中。您可以通过定义自己的控制器来优化或繼承模块的行为。本节将教您如何定义自己的控制器并编写自定义動作。<br>
      <h3 id="toc2"><a name="Lesson 7: Refining the standard behavior-Custom actions-Typical controller"></a>Typical 控制器</h3>
      默认情况下，Invoice 模块會使用来自 Typical 控制器的動作。此控制器在 <a class="wiki_link" href="https://github.com/openxava/openxava/tree/master/openxava/src/main/resources/xava">github 的 xava 文件夹</a><em></em> 中的 default-controllers.xml 裡。控制器的定义是一串 XML 裡包括动作的列表 。 OpenXava 默认将 Typical 控制器应用于所有模块。你可以看它的定义：<br>
      <pre><code class="xml">&lt;controller name="Typical"&gt; &lt;!-- 'Typical' 从以下控制器中继承它们的动作 --&gt;
    &lt;extends controller="Navigation"/&gt; &lt;!-- 從'Navigation', --&gt;
    &lt;extends controller="CRUD"/&gt; &lt;!-- 從'CRUD' --&gt;
    &lt;extends controller="Print"/&gt; &lt;!-- 從'Print' --&gt;
    &lt;extends controller="ImportData"/&gt; &lt;!-- 和從 'ImportData' 控制器中--&gt;
&lt;/controller&gt;
</code></pre> 在这里，您可以看到如何从其他控制器定义一個控制器。这是控制器中的继承。在这种情况下，Typical 控制器拥有 Navigation、Print 和 CRUD 控制器的動作。Navigation 可以在详细模式下瀏覽对象的動作。Print 包含打印 PDF 报告以及导出到 Excel 的動作。 CRUD 由創建、读取、更新和删除的動作组成。 ImportData 允许加载具有表格格式（csv、xls、xlsx）的文件以将记录导入模块的動作。以下代碼顯示 CRUD 控制器的摘录：<br>
      <pre><code class="xml">&lt;controller name="CRUD"&gt;
 
    &lt;action name="new"
        class="org.openxava.actions.NewAction"
        image="new.gif"
        icon="library-plus"
        keystroke="Control N"
        loses-changed-data="true"&gt;
        &lt;!--
        name="new": 用于从应用程序其他地方引用该动作的名称
        class="org.openxava.actions.NewAction" : 具有动作逻辑的类
        image="images/new.gif": 此动作的图像,
            in case "useIconsInsteadOfImages = false" of "xava.properties"
        icon="library-plus": 默认情况下此动作显示的图标
        keystroke="Control N": 用户可以按下以用来执行此动作的键
        loses-changed-data="true": 如果用户点击这个动作并没有事先保存则丢失当前数据
        --&gt;
        &lt;set property="restoreModel" value="true"/&gt; <br>	&lt;!-- 动作类的 restoreModel 属性会在执行之前设置为true --&gt;
    &lt;/action&gt;
 
    &lt;action name="save" mode="detail"
        by-default="if-possible"
        class="org.openxava.actions.SaveAction"
        image="save.gif"
        icon="content-save"
        keystroke="Control S"/&gt;
        &lt;!--
        mode="detail": 此动作仅在详细模式下显示
        by-default=”if-possible”: 当用户按下 ENTER 键时将执行此动作
        --&gt;
 
    &lt;action name="delete" mode="detail"
        confirm="true"
        class="org.openxava.actions.DeleteAction"
        image="delete.gif"
        icon="delete"
        available-on-new="false"
        keystroke="Control D"/&gt;
        &lt;!--
        confirm="true" : 会在执行动作之前询问用户
        available-on-new="false" : 创建新实体时，此动作不可用
        --&gt;
 
    &lt;!-- 更多动作... --&gt;
&lt;/controller&gt;
</code></pre> 在上面您可以看到如何定义動作。基本上，相当于将名称与執行該逻辑的类链接起来。此外，它定义了一个图標和一个按键，并且如何使用 &lt;set /&gt; 配置动作类。<br>
      默认情况下，动作會以列表和详细模式显示。不過，您可以通过 mode 属性指定动作应仅以“列表”或“详细”模式显示。<br>
      <h3 id="toc3"><a name="Lesson 7: Refining the standard behavior-Custom actions-Refining the controller for a module"></a>优化一个模块的控制器</h3>
      首先，我们将優化 Invoice 模块的删除動作。我们的目标是修改删除的过程，以便当用户点击删除按钮時发票不会被删除，而是简单地标记为已删除。这样，我们可以在需要时恢复已删除的发票。<br>
      <img src="files/refining_behavior_en010.png" alt="refining_behavior_en010.png"
        title="refining_behavior_en010.png"><br>
      上图显示 Typical 的動作。我们希望 Invoice 模块包含这些動作，除了删除的動作，我們將為它编写我們自己的逻辑。<br>
      您必须在项目中 src/main/resources/xava 文件夹的 controllers.xml 文件中为 Invoice 定义自己的控制器，如下：<br>
      <pre><code class="xml">&lt;?xml version = "1.0" encoding = "ISO-8859-1"?&gt;
 
&lt;!DOCTYPE controllers SYSTEM "dtds/controllers.dtd"&gt;
 
&lt;controllers&gt;
 
    &lt;controller name="Invoice"&gt; &lt;!-- 与实体同名 --&gt;
 
        &lt;extends controller="Typical"/&gt; &lt;!-- 拥有来自 Typical 的所有动作 --&gt;
 
        &lt;!-- Typical 已经有一个删除的动作，通过使用相同的名称来覆盖它 --&gt;
        &lt;action name="delete"
            mode="detail" confirm="true"
            class="com.yourcompany.invoicing.actions.DeleteInvoiceAction"
            icon="delete"
            available-on-new="false"
            keystroke="Control D"/&gt;
 
    &lt;/controller&gt;
 
&lt;/controllers&gt;
</code></pre> 要为您的实体定义控制器，必须创建一个与实体同名稱的控制器，也就是說，如果存在名为 Invoice 的控制器，则在运行 Invoice 模块时将會使用此控制器而不是 Typical。</div>
    <div class="wiki" style="display: block;">我們的 Invoice 控制器從 Typical 扩展，因此Typical 中的所有動作都可用于 Invoice 模块。在 Invoice 控制器中定义的任何動作都是可供用户點击的按钮。不過由于我们将动作命名为 delete，跟 Typical 控制器裡的动作同名，因此我们將覆盖它。换句话说，只有我们新的删除動作会出现在用户界面中。<br>
      <h3 id="toc4"><a name="Lesson 7: Refining the standard behavior-Custom actions-Writing your own action"></a>编写您的动作</h3>
      首先，创建一个名为 com.yourcompany.invoicing.actions 的新包。然后在其中创建一个名為 DeleteInvoiceAction 的类，代码如下：<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions;  // 在 actions 包

import org.openxava.actions.*;
 
public class DeleteInvoiceAction
    extends ViewBaseAction { // ViewBaseAction 有 getView()、addMessage()、等
 
    public void execute() throws Exception { // 动作的逻辑
        addMessage( // 添加一条消息以显示给用户
            "Don't worry! I only have cleared the screen");
        getView().clear(); // getView() 返回 xava_view 对象
            // clear() 清除用户界面中的数据
    }
}
</code></pre> 动作是个简单的类。它有一个 execute() 方法，是用户点击相应的按钮或链接时會执行的逻辑。一个动作必须实现 org.openxava.actions.IAction 接口，不過通常从 org.openxava.actions 包中扩展 BaseAction、ViewBaseAction 或任何其他基本动作更方便。<br>
      ViewBaseAction 有一个视图属性，您可以在 execute() 中使用 getView()。这个 org.openxava.view.View 类型的对象允许您管理用户界面。在上面我们使用 getView().clear() 清除所显示的数据。<br>
      我们还使用 addMessage()。 所有 addMessage() 添加的消息将在動作执行结束时显示於用户。您可以在 src/main/resources/i18n/invoicing-messages_zh.properties 中添加要显示的消息或条目的 id。<br>
      在下图中演示了添加自定义删除操作后 Invoice 模块的行为：<br>
      <img src="files/refining_behavior_en020.png" alt="refining_behavior_en020.png"
        title="refining_behavior_en020.png"><br>
      这当然是非常笨的行为，所以现在让我们給它添加真正的功能。为了在不刪除的情況下將發票标记为已删除，我们需要在 Invoice 添加一个新属性。我们称它为 deleted。如下：<br>
      <pre><code class="java">@Hidden // 默认情况下不会在视图和列表中显示
@Column(columnDefinition="BOOLEAN DEFAULT FALSE") // 填充 false 而不是空
boolean deleted;
</code></pre> 如您所见，它是一个普通的布尔属性。唯一的细节是使用 @Hidden 注解。这意味着当生成默认视图或表格列表时，将不会显示已删除的属性；不過如果您将其放入 @View(members=) 或 @Tab(properties=) 中，它将显示出来。将此注解運用于供开发人员内部使用和查看但对用户没有意义的属性上。<br>
      我们使用 @Column(columnDefinition=) 在列中填充 false 而不是 null。在这里，您可以定义 SQL 的列。对於更新数据库会更快，但代码更依赖于数据库。<br>
      我们现在为您的動作编写它真正的代码：<br>
      <pre><code class="java">public void execute() throws Exception {
    Invoice invoice = XPersistence.getManager().find(
        Invoice.class,
        getView().getValue("oid")); // 我们从视图中读取 id
    invoice.setDeleted(true); // 修改实体的状态
    addMessage("object_deleted", "Invoice"); // 删除的消息
    getView().clear(); // 清除视图
}
</code></pre> 视觉效果是一样的，显示一条消息并清除视图，但在这种情况下，我们实际上還做了一些工作。我们找到与当前视图关联的 Invoice 实体并修改其的已删除属性。我們只需要做這些，因为 OpenXava 会自动提交 JPA 事务。这意味着您可以读取任何对象并从动作中修改其状态，并且当动作完成时，修改后的值将存储在数据库中。<br>
      但我们在这里留下了一个松散的结局。 “删除”按钮在删除实体后仍保留在视图中，也就是刪除後沒有对象，如果用户再次點击该按钮，搜索指令将失败，并向用戶显示一条有点技术性和难以理解的消息。我们可以通过不显示按钮来优化这种情况，例如在我们单击新建按钮时。注意execute()的小修改：<br>
      <pre><code class="java">public void execute() throws Exception {
    // ...
    getView().clear();
    getView().setKeyEditable(true); // 新建实体
}
</code></pre> 使用 getView().setKeyEditable(true) 表示我们正在创建一个新实体，并且由于此動作的 available-in-new 属性為 false ，因此不会显示删除按钮。<br>
      现在您己知道如何编写自己的自定义動作，是时候看看如何编写通用代码了。<br>
      <h2 id="toc5"><a name="Lesson 7: Refining the standard behavior-Generic actions"></a>通用动作</h2>
      上面的 DeleteInvoiceAction 代码是编写動作的典型方法。該代碼直接访问和操作您的实体。<br>
      但有时您在動作中會碰到能在這应用程序重復使用的逻辑，甚至能在其它应用程序中使用的。而在这种情况，您可以使用一些技術来編寫可重用的代码，将您的自定义的動作转换为通用動作。<br>
      让我们看如何用这些技术来编写通用的動作代码。<br>
      <h3 id="toc6"><a name="Lesson 7: Refining the standard behavior-Generic actions-MapFacade for generic code"></a>使用 MapFacade 的通用代码</h3>
      想象一下，您也想将 DeleteInvoiceAction 用于 Order 实体。不！假设您想将它用在此應用程序中，所有擁有已删除属性的實體。也就是说，您希望有一個動作能标记为已删除，而不是实际从数据库中删除，不止在發票上而是所有實體。在这种情况下，僅僅用当前代码是不够的。您需要更通用的代码。<br>
      您可以使用 OpenXava 中名为 MapFacade 的类來开发通用的動作。 MapFacade（来自 org.openxava.model 包）允许您使用 Map 管理实体的状态，这非常实用，因为 View 也是使用 Map 工作的。此外，Map 比对象更加动态，因此更适合通用代码。<br>
      让我们重写删除動作。首先，将其从 DeleteInvoiceAction（删除 Invoice 对象的動作）重命名为 InvoicingDeleteAction（Invoicing 应用程序的删除動作）。这意味着您必须更改 controllers.xml 中動作的类名条目：<br>
      <pre><code class="xml">&lt;action name="delete"
    mode="detail" confirm="true"
    class="com.yourcompany.invoicing.actions.InvoicingDeleteAction"
    icon="delete"
    available-on-new="false"
    keystroke="Control D"/&gt;
</code></pre> 现在，将您的 DeleteInvoiceAction 重命名为 InvoicingDeleteAction 并编写其代码：<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions;
 
import java.util.*;
 
import org.openxava.actions.*;
import org.openxava.model.*;
 
public class InvoicingDeleteAction extends ViewBaseAction {

    public void execute() throws Exception {
        Map&lt;String, Object&gt; values =
            new HashMap&lt;&gt;(); // 实体中要修改的值
        values.put("deleted", true); // 我们将 deteled 属性设置为 true
        MapFacade.setValues( // 修改该实体的值
            getModelName(), // 来自 ViewBaseAction 的方法
            getView().getKeyValues(), // 要修改的实体的键
            values); // 要改变的值
        resetDescriptionsCache(); // 清除組合的缓存
        addMessage("object_deleted", getModelName());
        getView().clear();
        getView().setKeyEditable(true);
        getView().setEditable(false); // 將视图設为不可编辑
    }
}
</code></pre> 這個動作所执行的逻辑与前一个動作一樣，但它不引用 Invoice 实体。所以此動作是通用的，您可以将其与 Order、Author 或任何其他实体一起使用，只要它们具有已删除的属性即可。诀窍在于 MapFacade允许您由 Map 修改实体。这些映射可以直接从视图中获取（使用 getView().getKeyValues()），也可以像上面的值一样创建。<br>
      此外，您可以看到对上個版本的两个改进。首先，我们调用来自 BaseAction 的 resetDescriptionsCache() 方法。此方法用於清除组合的缓存。当您修改实体时，如果您希望组合即时更改，则需要这样做。其次，我们调用 getView().setEditable(false)。这会禁用视图的编辑器，以防止用户在视图中填写数据。如果要创建新实体，用户必须點击新建。<br>
      现在您的動作已准备好与任何实体使用。我们可以将 Invoice 控制器在 controllers.xml 中复制并粘贴，作为 Order 控制器使用。这样，我们新的通用删除逻辑也将用于 Order。等一下！我剛剛说“复制和粘贴”吗？我们不想墜落地狱，对吧？因此，我们将使用一种更自动化的方式将我们新的動作应用于所有模块。让我们看下一节。<br>
      <h3 id="toc7"><a name="Lesson 7: Refining the standard behavior-Generic actions-Changing the default controller for all modules"></a>更改所有模块的默认控制器</h3>
      如果您只为 Invoice 使用 InvoicingDeleteAction，那么在 controllers.xml 的 Invoice 控制器中定义它是一个不错的方法。但是，我们剛剛改进了这个动作，唯一的目的是让它可重用，所以让我们重用它。为此，我们将一次性为所有模块分配控制器。<br>
      第一步是在 controllers.xml 中将控制器的名称从 Invoice 更改为 Invoicing：<br>
      <pre><code class="xml">&lt;controller name="Invoicing"&gt;
 
    &lt;extends controller="Typical"/&gt;
 
    &lt;action name="delete"
        mode="detail" confirm="true"
        class="com.yourcompany.invoicing.actions.InvoicingDeleteAction"
        icon="delete"
        available-on-new="false"
        keystroke="Control D"/&gt;
 
&lt;/controller&gt;
</code></pre> 如您所知，当您使用实体的名称（如 Invoice）作为控制器名称时，该控制器将默认用于该实体的模块。因此，如果我们更改控制器的名称，该控制器将不会用于实体。实际上，任何模块都没有使用 Invoicing 控制器，因为没有称为 Invoicing 的实体。<br>
      我们想让 Invoicing 控制器成为我们应用程序中所有模块的默认控制器。为此，我们需要修改位于 src/main/resources/xava 文件夹中的 application.xml 文件。如下：<br>
      <pre><code class="xml">&lt;?xml version = "1.0" encoding = "ISO-8859-1"?&gt;
 
&lt;!DOCTYPE application SYSTEM "dtds/application.dtd"&gt;
 
&lt;application name="invoicing"&gt;
 
    &lt;!--
    A default module for each entity is assumed with the
    controllers on &lt;default-module/&gt;
    --&gt;
    &lt;default-module&gt;
        &lt;controller name="Invoicing"/&gt;
    &lt;/default-module&gt;
 
&lt;/application&gt;
</code></pre> 通过这种简单的方式，您应用程序的所有模块都将使用 Invoicing 为默认控制器，而不是 Typical 。試著执行您的 Invoice 模块并查看在删除时如何执行 InvoicingDeleteAction。<br>
      您也可以尝试 Order 模块删除，但它不会執行，因为它没有 deteled 属性。我们可以将 deleted 属性添加到 Order 中，並與新的控制器一起使用，但我们将使用更好的方法，而不是将 deleted 属性“复制并粘贴”到我们所有的实体中。我们在下一节中看如何。<br>
      <h3 id="toc8"><a name="Lesson 7: Refining the standard behavior-Generic actions-Come back to the model a little"></a>先回到模型类</h3>
      现在您的任务是将 deleted 属性添加到应用程序的所有实体中，以讓 InvoicingDeleteAction 起作用。这是個使用继承将共享的代码放在同一个地方的好时机，而不是使用臭名昭著的“复制和粘贴”。<br>
      首先从 Invoice 中删除 deleted 的属性：<br>
      <pre><code class="java">public class Invoice extends CommercialDocument {
 
    //@Hidden
    //@Column(columnDefinition="BOOLEAN DEFAULT FALSE")
    //boolean deleted;
 
    // ...
}
</code></pre> 现在在 com.yourcompany.invoicing.model 包中创建一个名为 Deletable 的新映射超类：
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
import org.openxava.annotations.*;
import lombok.*;
 
@MappedSuperclass @Getter @Setter
public class Deletable extends Identifiable {
 
    @Hidden
    @Column(columnDefinition="BOOLEAN DEFAULT FALSE")
    boolean deleted;
 
}
</code></pre> Deletable 是一个映射式超类。请记住，映射式超类不是实体，而是具有属性、方法和映射注解的类，可作為实体的超类。 Deletable 从 Identifiable 扩展而来，因此任何扩展 Deletable 的实体都将具有 oid 和 deleted 属性。<br>
      现在您可以将任何实体转换为可删除的实体，只需将 Identifiable 超类更改为 Deletable。現在將 CommercialDocument 修改：<br>
      <pre><code class="java">// abstract public class CommercialDocument extends Identifiable { 
abstract public class CommercialDocument extends Deletable { 
...
</code></pre> 鉴于 Invoice 和 Order 是 ComercialDocument 的子类，现在您可以在它們使用 Invocing 控制器和 InvoicingDeleteAction。<br>
      不過還有一个小细节仍然存在。 Order 实体有一个 @PreRemove 方法来对删除時进行验证。此验证可以防止删除。我们可以通过覆盖 Order 的 setDeleted() 方法来保持本章自定义删除的验证： <br>
      <pre><code class="java">public class Order extends CommercialDocument {
    // ...
 
    @PreRemove
    private void validateOnRemove() { // 现在这个方法不会自动执行
        if (invoice != null) { // 因为没有完成真正的删除
            throw new javax.validation.ValidationException(
                XavaResources.getString(
                    "cannot_delete_order_with_invoice"));
        }
    }
 
    public void setDeleted(boolean deleted) {
        if (deleted) validateOnRemove(); // 调用验证
        super.setDeleted(deleted);
    }
}
</code></pre> 通过此更改，验证就像在真正的删除案例中一样執行，這樣就不用改變原始的行为。<br>
      <h3 id="toc9"><a name="Lesson 7: Refining the standard behavior-Generic actions-Metadata for more generic code"></a>使用元数据以达到更加通用的代码</h3>
      当前 Invoice 和 Order 可以正常工作。不過如果您尝试删除任何其他模块中的实体，您将收到一条错误的消息。下图显示了当您尝试删除客户时会发生什么。<br>
      <img src="files/refining_behavior_en030.png" alt="refining_behavior_en030.png"
        title="refining_behavior_en030.png"><br>
      如果您的实体没有 deleted 的属性，则删除操作将失败。是的，您可以使用 Deletable 來添加 deleted 属性。但是，您可能希望在某些實體中可以使用体标但不刪除，而另些實體會真的從数据库中將實體刪除。我们希望盤動作在所有情况下都有效。<br>
      OpenXava 會存储所有实体的元数据（Metadata），您可以从代码中访问此元数据。这使您可以确定实体是否具有 deleted 的属性。<br>
      下面的代码展示了如何修改动作，以查明实体是否具有 deleted 的属性，如果没有，则不执行删除的过程：<br>
      <pre><code class="java">public void execute() throws Exception {
    if (!getView().getMetaModel() // 当前实体的元数据
        .containsMetaProperty("deleted")) // deleted 属性是否存在
    {
        addMessage( // 目前，仅在 deleted 不存在时显示消息
            "Not deleted, it has no deleted property");
        return;
    }
    // ...
}
</code></pre> 这里的关键是 getView().getMetaModel()，它从 org.openxava.model.meta 包返回一个 MetaModel 对象。此对象包含当前视图中的实体的元数据。您可以询问其属性、引用、集合、方法和其它該实体的元数据。想了解更多信息請查閱 <a
        href="../apidocs/org/openxava/model/meta/MetaModel.html">MetaModel API</a>。在这种情况，我们询问 deleted 属性是否存在並且只顯示一條消息。让我们对此进行改进，變成能实际删除实体。<br>
      <h3 id="toc10"><a name="Lesson 7: Refining the standard behavior-Generic actions-Call another action from an action"></a>从动作调用另一个动作</h3>
      我們想在实体缺少 deleted 属性時，會以通常的方式删除该实体。我们的第一个选择是自己编写删除逻辑，这是相当简单的任务。尽管如此，使用 OpenXava 的标准删除逻辑是一个更好的主意，因为我们不需要编写任何删除逻辑，并且使用了更精细和经过测试的一段代码。<br>
      对于此，OpenXava 允许从一個动作中调用另一個动作，只需使用 executeAction() 指示动作的名称，也就是說，控制器的名称和动作的名称。在這情況，我们要调用 OpenXava 标准的删除動作，我们应该使用 executeAction("CRUD.delete")。以下代码显示了修改为 OpenXava 標準删除動作的 InvoicingDeleteAction：<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions;
 
import java.util.*;
import org.openxava.actions.*;
import org.openxava.model.*;
 
public class InvoicingDeleteAction extends ViewBaseAction {

    public void execute() throws Exception {
        if (!getView().getMetaModel().containsMetaProperty("deleted")) {
            executeAction("CRUD.delete"); // 我们调用 OpenXava 标准的删除动作
            return;
        }
   	
        // 当 deleted 存在时，會使用我们自己的删除逻辑
        Map&lt;String, Object&gt; values = new HashMap&lt;&gt;(); 
        values.put("deleted", true);
        MapFacade.setValues(getModelName(), getView().getKeyValues(), values); 
        resetDescriptionsCache(); 
        addMessage("object_deleted", getModelName());
        getView().clear();
        getView().setKeyEditable(true);
        getView().setEditable(false); 
    }
}
</code></pre> </div>
    <div class="wiki" style="display: block;">如果我们想要执行 OpenXava 的默认删除動作，就调用 executeAction(“CRUD.delete”)。因此，我们编写自定义删除逻辑在某些情况下使用（並将属性标记为 true），而对于其它情况，我们會“绕过”它並只使用标准逻辑。<br>
      现在您可以将 InvoicingDeleteAction 与任何实体一起使用。如果实体有一个已删除的属性，它将被标记为已删除，否则它會直接从数据库中删除。<br>
      此示例向您展示如何使用 executeAction() 来优化 OpenXava 标准的逻辑。另一种方法是通过继承。让我们在下一节中看看如何。<br>
      <h3 id="toc11"><a name="Lesson 7: Refining the standard behavior-Generic actions-Refining the default search action"></a>优化默认搜索的动作</h3>
      现在，您的 InvoicingDeleteAction 已正常運作，尽管它的用處不是很大。因為将一個对象标记为已删除是没有用的，畢竟在其它地方還是看的到。换句话说，我们必须修改应用程序的其它部分，以将标记为已删除的对象视为它们不存在。<br>
      最明显的是搜索的動作。如果您删除发票後再搜索它，则不应該找到它。下图显示了搜索在 OpenXava 中的工作方式。<br>
      <img src="files/refining_behavior_en040.png" alt="refining_behavior_en040.png"
        title="refining_behavior_en040.png"><br>
      在上图中首先要观察的是，在详细模式下搜索比它原本看起来更灵活。用户可以在任何字段或一组字段中输入任何值，然后點击刷新按钮，而第一个匹配的对象将被加载到视图中。<br>
      现在您可能会想：好吧，我可以像改进 CRUD.delete 一样改进 CRUD.refresh 动作。是的，可以，而且会奏效；当用户點击详细模式的刷新操作时，您的代码将被执行。然而，这里有个微妙的细节。搜索逻辑不仅會从详细模式中调用，也在 OpenXava 模块中其他地方调用。例如，当用户从列表模式中选择一个详细信息时，List.viewDetail 動作會获取該行的键，将其放入详细信息视图中，然后执行搜索的動作。<br>
      如果要正確的做，得将搜索逻辑放在一个動作、一個模塊中，而所有需要用到搜索的动作都得链接到这个动作上。如上图所示。<br>
      当您看到 CRUD.refresh 的動作代碼時 （在 org.openxava.actions.SearchAction），會更好理解，其代码如下：<br>
      <pre><code class="java">public class SearchAction extends BaseAction
    implements IChainAction { // 它链接到另一个动作
 
    public void execute() throws Exception { // 什么都不做
    }
 
    public String getNextAction() throws Exception { // IChainAction
        return getEnvironment() // 用於访问环境变量
            .getValue("XAVA_SEARCH_ACTION");
    }
}
</code></pre> 如您所见，详细模式下的标准搜索動作除了鏈接到另一个動作之外，什么都不做。另一個動作則在环境变量中定义为 XAVA_SEARCH_ACTION，并且可以使用 getEnvironment() 读取。因此，如果您想优化 OpenXava 的搜索逻辑，最好的方法是将您的動作定义为 XAVA_SEARCH_ACTION。所以，让我们这样做。<br>
      想要设置环境变量，请编辑项目 src/main/resources/xava 文件夹中的 controllers.xml 文件，并在开头添加 &lt;env-var /&gt;：<br>
      <pre><code class="xml">...
&lt;controllers&gt;
    &lt;!-- 为环境变量定义全局变量 --&gt;
    &lt;env-var
        name="XAVA_SEARCH_ACTION"
        value="Invoicing.searchExcludingDeleted" /&gt;
 
    &lt;controller name="Invoicing"&gt;
...
</code></pre> 这样，任何模块中的 XAVA_SEARCH_ACTION 环境变量的值都将成为 Invoicing.searchExcludingDeleted，因此，所有模块的搜索逻辑都将在此動作中。<br>
      接下来，我们在 controllers.xml 中定义这个动作：<br>
      <pre><code class="xml">&lt;controller name="Invoicing"&gt;
    ...
    &lt;action name="searchExcludingDeleted"
        hidden="true"
        class="com.yourcompany.invoicing.actions.SearchExcludingDeletedAction"/&gt;
        &lt;!-- hidden="true": 该动作不会显示在按钮栏中 --&gt;
 
&lt;/controller&gt;
</code></pre> 现在是时候编写一個实现类了。在这种情况下，我们只想优化搜索逻辑，以便以常规方式完成搜索，但它会忽略已删除设置为 true 的实体。为了进行这种细化，我们将使用继承。nd now it's time to write the implementation class. In this case we only want to refine the search logic so that the search is done the regular way with the exception that it is leaving out entities where <em>deleted</em> is set to true. To do this refinement we are going to use inheritance.<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions;
 
import java.util.*;
import javax.ejb.*;
import org.openxava.actions.*;
 
public class SearchExcludingDeletedAction
    extends SearchByViewKeyAction { // OpenXava 的标准搜索动作
 
    private boolean isDeletable() { // 查看该实体是否有 deleted 属性
        return getView().getMetaModel()
            .containsMetaProperty("deleted");
    }
 
    protected Map getValuesFromView() // 获取该视图中显示的值，该用于搜索的键
        throws Exception
    {
        if (!isDeletable()) { // / 如果不是 Deletable，将运行标准逻辑
            return super.getValuesFromView();
        }
        Map&lt;String, Object&gt; values = super.getValuesFromView();
        values.put("deleted", false); // 将 deleted 的属性设為 false
        return values;
    }
 
    protected Map getMemberNames() // 要从实体中读取的成员
        throws Exception
    {
        if (!isDeletable()) { // 如果不是 Deletable，我们运行标准逻辑
            return super.getMemberNames();
        }
        Map&lt;String, Object&gt; members = super.getMemberNames();
        members.put("deleted", null);  // 我们想从实体中获取 deleted 的属性，就算它可能不在视图中
        return members;
    }
 
    protected void setValuesToView(Map values) // 将实体中的值赋给视图
        throws Exception 
    {
        if (isDeletable() &amp;&amp; // 如果它有一个 deleted 属性并且是 true
            (Boolean) values.get("deleted")) {
                throw new ObjectNotFoundException(); // 当 OpenXava 找不到对象时抛出的异常
        } // throws when the object is not found
        else {
            super.setValuesToView(values); // 相反我们則运行标准逻辑
        }
    }
}
</code></pre> The standard logic to search resides in the <i>SearchByViewKeyAction</i> class. Basically, what this action does is that it reads the values from the view and searches for an object. If the id property is present this is used, otherwise all values are used, and the first object that matches the condition is returned. We want to use this same algorithm changing only some details about the <em>deleted</em> property. So instead of overwriting the <i>execute()</i> method, that contains the search logic, we overwrite three protected methods, that are called from <i>execute()</i> and contain some parts suitable to be refined.<br>
      After these changes you can try your application, and you will find that when you search, a removed invoice or order will never be shown. Even if you choose a deleted invoice or order from list mode an error will be produced and you will not see the data in detail mode.<br>
      You have seen how defining a <em>XAVA_SEARCH_ACTION</em> environment variable in <em>controllers.xml</em> you establish the search logic in a global way for all your modules at once. If you want to define a specific search action for a particular module just define the environment variable in the module definition in <em>application.xml</em>, as we show below:<br>
      <pre><code class="xml">&lt;module name="Product"&gt;
    &lt;!-- To give a local value to the environment variable for this module --&gt;
    &lt;env-var
       name="XAVA_SEARCH_ACTION"
       value="Product.searchByNumber"/&gt;
    &lt;model name="Product"/&gt;
    &lt;controller name="Product"/&gt;
    &lt;controller name="Invoicing"/&gt;
&lt;/module&gt;
</code></pre> In this way for the module <em>Product</em> the <em>XAVA_SEARCH_ACTION</em> environment variable will be “Product.searchByNumber”. This way, the environment variables are local to the modules. You can define a default value in <em>controllers.xml</em>, but you always have the option to overwrite the value for particular modules. The environment variables are a powerful way to configure your application in an declarative way.<br>
      We don't want a special way to search for <em>Product</em>, so don't add this module definition to your <em>application.xml</em>. The code here is only to illustrate how to use <em>&lt;env-var /&gt;</em> in modules.<br>
      <h2 id="toc12"><a name="Lesson 7: Refining the standard behavior-List mode"></a>列表模式</h2>
      We have almost completed the job. When the user removes an entity with a <em>deleted</em> property the entity is marked as deleted instead of actually being removed from the database. And if the user attempts to search for a marked-as-deleted entity he cannot view it in detail mode. However, the user can still see such entities in list mode though, and even worse, if he deletes entities when in list mode, they are actually removed from the database. Let's fix these remaining details.<br>
      <h3 id="toc13"><a name="Lesson 7: Refining the standard behavior-List mode-Filtering tabular data"></a>筛选表格数据</h3>
      Only entities where the deleted property is false should be shown in list mode. This is very easy to achieve using the <i>@Tab</i> annotation. This annotation allows you to define the way the tabular data (the data shown in list mode) is displayed, moreover it allows you to define a condition. So, adding this annotation to the entities with <em>deleted</em> property is sufficient to achieve our goal, as we show below:<br>
      <pre><code class="java">@Tab(baseCondition = "deleted = false")
public class Invoice extends CommercialDocument { ... }
 
@Tab(baseCondition = "deleted = false")
public class Order extends CommercialDocument { ... }
</code></pre> And in this simple way the list mode will not show the marked-as-deleted entities.<br>
      <h3 id="toc14"><a name="Lesson 7: Refining the standard behavior-List mode-List actions"></a>列表的动作</h3>
      The only remaining detail is that when removing entities from list mode, they should be marked as deleted if applicable. We are going to refine the standard <em>CRUD.deleteSelected</em> and <i>CRUD.deleteRow</i> actions in the same way we used for <em>CRUD.delete</em>.<br>
      First, we overwrite the <em>deleteSelected</em> and <em>deleteRow</em> actions for our application. Add the following action definition to your <em>Invoicing</em> controller defined in <em>controllers.xml</em>:<br>
      <pre><code class="java">&lt;controller name="Invoicing"&gt;
    &lt;extends controller="Typical"/&gt;
     ...
    &lt;action name="deleteSelected" mode="list" confirm="true"
        process-selected-items="true"
        icon="delete"			 
        class="com.yourcompany.invoicing.actions.InvoicingDeleteSelectedAction"
        keystroke="Control D"/&gt;				
	
    &lt;action name="deleteRow" mode="NONE" confirm="true"
        class="com.yourcompany.invoicing.actions.InvoicingDeleteSelectedAction"
        icon="delete"
        in-each-row="true"/&gt;
        
&lt;/controller&gt;
</code></pre> The standard actions to remove entities from list mode are <em>deleteSelected</em> (to delete the checked rows) and <em>deleteRow</em> (the action displayed in each row). These actions are defined in the <em>CRUD</em> controller. <em>Typical</em> extends <em>CRUD</em>, and <em>Invoicing</em> extends <em>Typical</em>; so <em>Invoicing</em> controller includes these actions by default. Given we have defined these actions with the same name, our actions overwrite the standard ones. That is, from now on the logic for removing selected rows in list mode is in the <em>InvoicingDeleteSelectedAction</em> class. Note how the logic for both actions is in the same Java class:<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions;
 
import org.openxava.actions.*;
import org.openxava.model.meta.*;
 
public class InvoicingDeleteSelectedAction
    extends TabBaseAction // To work with tabular data (list) by means of getTab()
    implements IChainActionWithArgv { // It chains to another action, returned by getNextAction() method
 
    private String nextAction = null; // To store the next action to execute
 
    public void execute() throws Exception {
        if (!getMetaModel().containsMetaProperty("deleted")) {
            nextAction="CRUD.deleteSelected"; // 'CRUD.deleteSelected' will be
            return;    // executed after this action is finished
        }
        markSelectedEntitiesAsDeleted(); // The logic to mark the selected rows
            // as deleted objects
    }
 
    private MetaModel getMetaModel() {
        return MetaModel.get(getTab().getModelName());
    }
 
    public String getNextAction() // Required because of IChainAction
        throws Exception
    {
        return nextAction; // If null no action will be chained
    }
 
    public String getNextActionArgv() throws Exception {
        return "row=" + getRow(); // Argument to send to chainged action
    }
 
    private void markSelectedEntitiesAsDeleted() throws Exception {
        // ...
    }
 
}
</code></pre> You can see that this action is very similar to <em>InvoicingDeleteAction</em>. If the selected entities don't have the deleted property it chains to the standard action, otherwise it executes its own logic to delete the entities. Although in this case we use <i>IChainActionWithArgv</i> instead of a simpler <i>executeAction()</i> because we need to send an argument to the chained action. Usually the actions for list mode extend <i>TabBaseAction</i>, thus you can use <i>getTab()</i> to obtain the <i>Tab</i> object associated to the list. A <em>Tab</em> (from <i>org.openxava.tab</i>) allows you to manage the tabular data. For example in the <i>getMetaModel()</i> method we retrieve the model name from the <i>Tab</i> in order to obtain the corresponding <i>MetaModel</i>.<br>
      If the entity has a <em>deleted</em> property then our custom delete logic is executed. This logic is in the <em>markSelectedEntitiesAsDeleted()</em> method:<br>
      <pre><code class="java">private void markSelectedEntitiesAsDeleted() throws Exception {
    Map&lt;String, Object&gt; values = new HashMap&lt;&gt;(); // Values to assign to each entity to be marked
    values.put("deleted", true); // Just set deleted to true
    Map&lt;String, Object&gt;[] selectedOnes = getSelectedKeys(); // We get the selected rows
    if (selectedOnes != null) {
        for (int i = 0; i &lt; selectedOnes.length; i++) { // Loop over all selected rows
            Map&lt;String, Object&gt; key = selectedOnes[i]; // We obtain the key of each entity
            try {
                MapFacade.setValues(  // Each entity is modified
                    getTab().getModelName(),
                    key,
                    values);
            }
            catch (javax.validation.ValidationException ex) { // If there is a ValidationException...
                addError("no_delete_row", i, key);
                addError("remove_error", getTab().getModelName(), ex.getMessage()); // ...we show the message
            }
            catch (Exception ex) { // If any other exception is thrown, a generic
                addError("no_delete_row", i, key); // message is added
            }
        }
    }
    getTab().deselectAll(); // After removing we deselect the rows
    resetDescriptionsCache(); // And reset the cache for combos for this user
}
</code></pre> As you see the logic is a plain loop over all selected rows, in each iteration we set the <em>deleted</em> property to true using <i>MapFacade.setValues()</i>. Exceptions are caught inside the loop, so if there is a problem deleting one of the entities, this does not affect the removal of the other entities. Furthermore, we have added a small refinement for the <i>ValidationException</i> case, adding the validation message <i>(ex.getMessage())</i> to the errors to be shown to the user.<br>
      Here we also deselect all rows by means of <i>getTab().deselectAll()</i>, because we are removing rows. If we don't remove the selection, it would be moved after the action execution.<br>
      We call <i>resetDescriptionsCache()</i> to update all combos in the current user session and remove all deleted entities. The combos (references marked with <i>@DescriptionsList</i>) use the <i>@Tab</i> of the referenced entity to filter the data. In our case all the combos for invoices and orders use the “deleted = false” condition of the <i>@Tab</i>. So, it's needed to reset the combos cache.<br>
      Now you have thoroughly improved the way your application deletes the entities. Nevertheless, there still remains a few interesting things we can do with this.<br>
      <h2 id="toc15"><a name="Lesson 7: Refining the standard behavior-Reusing actions code"></a>重用动作的代码</h2>
      Fantastic! Now your application marks the invoices and orders as deleted instead of actually removing them. One advantage of this approach is that in any given moment, the user can restore an invoice or order deleted by mistake. For this feature to be useful, you have to provide a tool for restoring the deleted entities. Therefore, we are going to create an <em>Invoice trash</em> and an <em>Order trash</em> to bring deleted documents back to life.<br>
      <h3 id="toc16"><a name="Lesson 7: Refining the standard behavior-Reusing actions code-Using properties to create reusable actions"></a>使用属性创建可重用的动作</h3>
      The trash we want is exhibited in the next figure. It is a list of invoices or orders where the user can choose several of them and click the <i>Restore</i> button, or alternatively, for a single entity, click the <i>Restore</i> link on the row of the item to restore.<br>
      <img src="files/refining_behavior_en050.png" alt="refining_behavior_en050.png"
        title="refining_behavior_en050.png"><br>
      The logic of this restore action is to set the <em>deleted</em> property of the selected entities to false. Obviously, this is the same logic we used for deleting, but setting deleted to false instead of true. Since our conscience does not allow us to copy and paste, we're going to reuse the present code. Just adding a <em>restore</em> property to <em>InvoicingDeleteSelectedAction</em> is enough to enable recovery of deleted entities.<br>
      <pre><code class="java">public class InvoicingDeleteSelectedAction ... {
    ...
    @Getter @Setter
    boolean restore; // A new restore property
  
    private void markSelectedEntitiesAsDeleted()
        throws Exception
    {
        Map&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();
        // values.put("deleted", true); // Instead of a hardcoded true, we use
        values.put("deleted", !isRestore()); // the restore property value
        // ...
    }
    // ...
}
</code></pre> As you can see, we only added a <em>restore</em> property, and then use its complement as the new value for the <em>deleted</em> property in the entity. If restore is false, (the default), <em>deleted</em> is set to <em>true</em>, meaning that we perform a deletion. But if <em>restore</em> is true the action will save the <em>deleted</em> property as <em>false</em>, making the invoice, order or whatever entity available again in the application.<br>
      To make this action available you have to define it in <em>controllers.xml</em>:<br>
      <pre><code class="xml">&lt;controller name="Trash"&gt;
    &lt;action name="restore" mode="list"
        class="com.yourcompany.invoicing.actions.InvoicingDeleteSelectedAction"&gt;
        &lt;set property="restore" value="true"/&gt; &lt;!-- Initialize the restore property to --&gt;
                &lt;!-- true before calling the execute() method of the action --&gt;
    &lt;/action&gt;
&lt;/controller&gt;
</code></pre> From now on you can utilize the <em>Trash.restore</em> action when you need an action for restoring. You're reusing the same code to delete and to restore, thanks to <em>&lt;set /&gt;</em> element of <em>&lt;action /&gt;</em> that allows you to configure the properties of your action.<br>
      Let's use this new restore action in the new trash modules.<br>
      <h3 id="toc17"><a name="Lesson 7: Refining the standard behavior-Reusing actions code-Custom modules"></a>自定义模块</h3>
      As you already know, OpenXava generates a default module for each entity in your application. Still, you always have the option of defining the modules by hand, either by refining the behavior of a certain entity module, or by defining completely new functionality associated to the entity. In this case we're going to create two new modules, <em>InvoiceTrash</em> and <em>OrderTrash</em>, to restore deleted documents. In these modules we will use the <em>Trash</em> controller. See how we define the module in the <em>application.xml</em> file:<br>
      <pre><code class="xml">&lt;application name="invoicing"&gt;
      
    &lt;default-module&gt;
        &lt;controller name="Invoicing"/&gt;
    &lt;/default-module&gt;
 
    &lt;module name="InvoiceTrash"&gt;
        &lt;env-var name="XAVA_LIST_ACTION"
            value="Trash.restore"/&gt; &lt;!-- The action to be shown in each row --&gt;
        &lt;model name="Invoice"/&gt;
        &lt;tab name="Deleted"/&gt; &lt;!-- To show only the deleted entities --&gt;
        &lt;controller name="Trash"/&gt; &lt;!-- With only one action: restore --&gt;
    &lt;/module&gt;
 
    &lt;module name="OrderTrash"&gt;
        &lt;env-var name="XAVA_LIST_ACTION" value="Trash.restore"/&gt;
        &lt;model name="Order"/&gt;
        &lt;tab name="Deleted"/&gt;
        &lt;controller name="Trash"/&gt;
    &lt;/module&gt;
    
&lt;/application&gt;
</code></pre> These modules work as <em>Invoice</em> and <em>Order</em>, but they define a specific action as a row action using the <em>XAVA_LIST_ACTION</em> environment variable. The next figure shows the <em>InvoiceTrash</em> module in action.<br>
      <img src="files/refining_behavior_en060.png" alt="refining_behavior_en060.png"
        title="refining_behavior_en060.png"><br>
      <h3 id="toc18"><a name="Lesson 7: Refining the standard behavior-Reusing actions code-Several tabular data definitions by entity"></a>从实体定义表格的数据</h3>
      Another important detail is that only deleted entities are shown in the list. This is possible because we define a specific <i>@Tab</i> by name for the module.<br>
      <pre><code class="xml">&lt;module ... &gt;
    ...
    &lt;tab name="Deleted"/&gt; &lt;!-- "Deleted" is a @Tab defined in the entity --&gt;
    ...
&lt;/module&gt;
</code></pre> Of course you must have a <i>@Tab</i> named “Deleted” in your <em>Order</em> and <em>Invoice</em> entities.<br>
      <pre><code class="java">@Tab(baseCondition = "deleted = false") // No name, so the default tab
@Tab(name="Deleted", baseCondition = "deleted = true") // A named tab
public class Invoice extends CommercialDocument { ... }
 
@Tab(baseCondition = "deleted = false")
@Tab(name="Deleted", baseCondition = "deleted = true")
public class Order extends CommercialDocument { ... }
</code></pre>You use the <i>@Tab</i> with no name as default list for <em>Invoice</em> and <em>Order</em>, but you have a <i>@Tab</i> named "Deleted" you can use for generating a list with only the deleted rows. In our context you use it for the trash modules. Now you can try your new trash modules, if you don't see it in the menu, sign out and sign in again.</div>
    <div class="wiki" style="display: block;">
      <h3 id="toc19"><a name="Lesson 7: Refining the standard behavior-Reusing actions code-Reusable obsession"></a>痴迷于重复使用</h3>
      We have done a good job! The <em>InvoicingDeleteSelectedAction</em> code can delete and restore entities, and we added the restore capacity with a very small amount of code and without copy &amp; paste.<br>
      Now a lot of pernicious thoughts are swarming around your head. Surely you are thinking: “This action is no longer a mere delete action, but rather a delete and restore action”, and then: “Wait a minute, it is actually an action that updates the deleted property of the current entity”, followed by your next thought: “With very little improvement we can update any property of the entity”.<br>
      Yes, you're right. You can easily create a more generic action, an <em>UpdatePropertyAction</em> for example; and use it to declare your <em>deleteSelected</em> and restore actions, thereby:<br>
      <pre><code class="xml">&lt;action name="deleteSelected" mode="list" confirm="true"
    class="com.yourcompany.invoicing.actions.UpdatePropertyAction"
    keystroke="Control D"&gt;
    &lt;set property="property" value="deleted"/&gt;
    &lt;set property="value" value="true"/&gt;
&lt;/action&gt;
 
&lt;action name="restore" mode="list"
    class="com.yourcompany.invoicing.actions.UpdatePropertyAction"&gt;
    &lt;set property="property" value="deleted"/&gt;
    &lt;set property="value" value="false"/&gt;
&lt;/action&gt;
</code></pre> Although it seems like a good idea, we're not going to create this flexible <em>UpdatePropertyAction</em>. Because the more flexible your code is, the more sophisticated it is. And we don't want sophisticated code. We want simple code, and though simple code is impossible to achieve, we must make an effort to have the simplest possible code. The advice is: create reusable code only when it simplifies your application right now.<br>
      <h2 id="toc23"><a name="Lesson 7: Refining the standard behavior-Summary"></a>总结</h2>
      The standard OpenXava behavior is only a starting point. Using the delete actions as excuse we have explored a couple of ways to refine the details of the application behavior. With the techniques in this lesson you can not only refine the delete logic, but fully alter the way your OpenXava application works. Thus, you have the possibility of tailoring the behavior of your application to fit your user expectations.<br>
      The default OpenXava behavior is pretty limited, only CRUD and reporting. If you want a valuable application for your user you need to add specific functionality to help your user solve his problems. We will do more of that in the next lesson.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-7-refining-standard-behavior_en.zip/download"
          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"
          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine? <a
          class="wiki_link" href="business-logic-behavior_en.html">Go to lesson 25</a></strong> </div>
  </body>
</html>
