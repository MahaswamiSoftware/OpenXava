<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lesson 26: References &amp; collections - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"><a name="references-collections"></a> <span id="breadcrumbs"> <span
            id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava </a> </span> / <a
            href="index_zh.html">文档</a> / </span>第 26 章：参照与集合</h1>
      <strong>课程：</strong><a class="wiki_link" href="getting-started_zh.html">1. 入门教学</a> | <a
        class="wiki_link" href="basic-domain-model1_zh.html">2. 基本域模型（上）</a> | <a
        class="wiki_link" href="basic-domain-model2_zh.html">3. 基本域模型（下）</a> | <a
        class="wiki_link" href="refining-user-interface_zh.html">4. 优化用户界面</a> | <a
        class="wiki_link" href="agile-development_zh.html">5. 敏捷开发</a> | <a
        class="wiki_link" href="mapped-superclass-inheritance_zh.html">6. 映射式超类继承</a> | <a
        class="wiki_link" href="entity-inheritance_zh.html">7. 实体继承</a> | <a
        class="wiki_link" href="view-inheritance_zh.html">8. 视图继承（View）</a> | <a
        class="wiki_link" href="java-properties_zh.html">9. Java 属性</a> | <a
        class="wiki_link" href="calculated-properties_zh.html">10. 计算属性</a> | <a
        class="wiki_link" href="defaultvaluecalculator-in-collections_zh.html">11. 用在集合的 @DefaultValueCalculator</a><strong> </strong> | <a
        class="wiki_link" href="calculation-and-collections-total_zh.html">12. @Calculation 和集合总计</a> | <a
        class="wiki_link" href="defaultvaluecalculator-from-file_zh.html">13. 从外部文件的 @DefaultValueCalculator</a> | <a
        class="wiki_link" href="manual-schema-evolution_zh.html">14. 手动更改 schema</a> <a
        class="wiki_link" href="manual-schema-evolution_en.html"></a> | <a
        class="wiki_link" href="multi-user-default-value-calculation_zh.html">15. 多用户时默认值的计算</a> | <a
        class="wiki_link" href="synchronize-persistent-and-computed-properties_zh.html">16. 同步持久属性和计算属性</a> | <a
        class="wiki_link" href="logic-from-database_zh.html">17. 从数据库中的逻辑</a> |<span
        style="color: #0000ee;"> </span><a class="wiki_link" href="validating-with-entityvalidator_zh.html">18. 使用 @EntityValidator 进行验证</a> | <a
        class="wiki_link" href="validation-alternatives_zh.html">19. 验证替代方案</a> | <a
        class="wiki_link" href="validation-on-remove_zh.html">20. 删除时验证</a> | <a
        class="wiki_link" href="custom-bean-validation-annotation_zh.html">21. 自定义 Bean Validation 注解</a> | <a
        class="wiki_link" href="rest-service-call-from-validation_zh.html">22. 在验证中调用 REST 服务</a> | <a
        class="wiki_link" href="attributes-in-annotations_zh.html">23. 注解中的属性</a> | <a
        class="wiki_link" href="refining-standard-behavior_zh.html">24. 改进标准行为</a> | <a
        class="wiki_link" href="business-logic-behavior_zh.html">25. 行为与业务逻辑</a> | <strong>26. 参照与集合 </strong> | <a
        class="wiki_link" href="philosophy_en.html">A. Architecture &amp; philosophy</a> | <a
        class="wiki_link" href="jpa_en.html">B. Java Persistence API</a> | <a
        class="wiki_link" href="annotations_en.html">C. Annotations</a> | <a
        class="wiki_link" href="testing_en.html">D. Automated testing</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">目录</h1>
        <div style="margin-left: 1em;"><a href="#references-collections">第 26 章：参照与集合</a></div>
        <div style="margin-left: 2em;"><a href="#refining-reference-behavior">优化参照行为</a></div>
        <div style="margin-left: 3em;"><a href="#validation-is-good-but-not-enough">验证虽然很好但还不够</a></div>
        <div style="margin-left: 3em;"><a href="#refining-action-for-searching-reference-with-list">优化在列表搜索参照的动作</a></div>
        <div style="margin-left: 3em;"><a href="#searching-the-reference-typing-in-fields">在输入字段时搜索参照</a></div>
        <div style="margin-left: 3em;"><a href="#refining-action-for-searching-reference-typing-key">优化输入键时的搜索</a></div>
        <div style="margin-left: 2em;"><a href="#refining-collection-behavior">优化集合的行为</a></div>
        <div style="margin-left: 3em;"><a href="#refining-the-list-for-adding-elements-to-a-collection">优化将元素添加到集合的列表</a></div>
        <div style="margin-left: 3em;"><a href="#refining-the-action-to-add-elements-to-a-collection">优化将元素添加到集合的动作</a></div>
        <div style="margin-left: 2em;"><a href="#summary">总结</a></div>
      </div>
      在之前的课程中，您学到如何添加自己的動作。然而，这还不足以完全自定义应用程序的行为，因为生成的用户界面，具体而言是參照和集合的用户界面，具有的标准行为有時並不是最方便的。<br>
      幸运的是，OpenXava 提供了许多方法来自定义參照和集合的行为。在本章，您将学到一些自定义的方法，以及它們如何为您的应用程序增加价值。
      <h2><a name="refining-reference-behavior"></a>优化参照行为</h2>
      您可能已经注意到订单模块有一个小漏洞：用户可以将他想要的任何发票添加到当前订单中，即使发票的客户不同。这是不能接受的，让我们修复它。
      <h3><a name="validation-is-good-but-not-enough"></a>验证虽然很好但还不够</h3>
      當发票和订单都属于同一客户時，用户才能将它們相关联。这是您应用程序的特定业务逻辑，因此标准的 OpenXava 行为无法解决它。下图显示当发票的客户不正确时会产生验证错误：</div>
    <img src="files/references-collections_en010.png" alt="references-collections_en010"
      title="references-collections_en010">
    <div class="wiki" style="display: block;"> 由于这是业务逻辑，我们會把它放在模型层，也就是实体中。我们在此添加验证，这样就可以得到上图的效果。</div>
    <div class="wiki" style="display: block;">您已经知道如何将此验证添加到您的 Order 实体了，它是一个用@AssertTrue 注解的方法：<br>
      <pre><code class="java">public class Order {

    ...

    // This method must return true for this order to be valid
    @AssertTrue(message="customer_order_invoice_must_match") 
    private boolean isInvoiceCustomerMatches() {
    	return invoice == null || // invoice is optional
    		invoice.getCustomer().getNumber() == getCustomer().getNumber();
    }

}
</code></pre>您还必须将消息添加到 src/main/resources/i18n/invoicing-messages_zh.properties：</div>
    <div class="wiki" style="display: block;">
      <pre><code class="properties">customer_order_invoice_must_match=发票和订单的客户必须匹配
</code></pre> </div>
    <div class="wiki" style="display: block;"> 在这里我们验证发票的客户和这个订单的客户是一样的，以保持数据完整性。但仅此验证是的話，對用戶來說會顯的有點不夠。
      <h3><a name="refining-action-for-searching-reference-with-list"></a>优化用于在列表搜索参照的动作</h3>
      尽管验证可以防止用户为订单分配不正确的发票，但也很难找到正确的发票。因为当用户點击搜索发票时，会显示所有的发票。我们将对此进行改进，以便仅显示当前客户的发票，如下：</div>
    <img src="files/references-collections_en020.png" alt="references-collections_en020.png"
      title="references-collections_en020.png"><br>
    <div class="wiki" style="display: block;"> 我们将使用 @SearchAction 注解來自定義搜索要參照的發票的動作。以下您可以看到在 Order 类中的修改：
      <pre><code class="java">public class Order extends CommercialDocument {

    @ManyToOne
    @ReferenceView("NoCustomerNoOrders")
    @OnChange(ShowHideCreateInvoiceAction.class)
    @SearchAction("Order.searchInvoice") // To define our own action to search invoices
    Invoice invoice;

    ...
	
}
</code></pre> 通过这简单的方式，我们定义了当用户點击搜索发票时要执行的動作。@SearchAction 的参数 Order.searchInvoice 是動作的名称，也就是在 controllers.xml 文件中定义的 Order 控制器的 searchInvoice 動作。现在我们必须编辑 controllers.xml 来添加我们新动作的定义：
      <pre><code class="xml">&lt;controller name="Order"&gt;

    ...
	
    &lt;action name="searchInvoice"
        class="com.yourcompany.invoicing.actions.SearchInvoiceFromOrderAction"
        hidden="true" icon="magnify"/&gt;
        &lt;!--
        hidden="true" : Because we don't want the action to be shown in module button bar
        icon="magnify" : The same icon as for the standard search action
        --&gt;
	
&lt;/controller&gt;
</code></pre> 我们的動作从 ReferenceSearchAction 扩展而来，如下：
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import org.openxava.actions.*; // To use ReferenceSearchAction

public class SearchInvoiceFromOrderAction
    extends ReferenceSearchAction { // Standard logic for searching a reference

    public void execute() throws Exception {
        int customerNumber =
            getView().getValueInt("customer.number"); // Reads from the view the
                                         // customer number of the current order
        super.execute(); // It executes the standard logic that shows a dialog
        if (customerNumber &gt; 0) { // If there is customer we use it to filter
            getTab().setBaseCondition("${customer.number} = " + customerNumber);
        }
    }
}
</code></pre> 可以看到我们如何使用 getTab().setBaseCondition() 为列表选參照而建立条件。也就是说，您可以从 ReferenceSearchAction 使用 getTab() 来操纵列表的行为。<br>
      如果没有客户，我们不添加任何条件，因此會显示所有发票，这是當用户在选择客户之前先选择发票的情况。
      <h3><a name="searching-the-reference-typing-in-fields"></a>在输入字段时搜索参照</h3>
      选择参照的列表已经好了。但是，我们也希望用户可以在不用列表時选择发票，只需输入年份和编号。這在用户知道他想要哪张发票時非常方便。 OpenXava 默认提供此功能。如果 @Id 字段显示在參照中，则會用它们搜索，相反则 OpenXava 會使用第一个字段进行搜索。这在我们的例子中并不方便，因为第一个显示的字段是年份，若仅按年份搜索发票會不準确。下图显示了默认的行为和一個更方便的替代方法：<br>
      <img src="files/references-collections_en030.png" alt="references-collections_en030.png"
        title="references-collections_en030.png"><br>
      幸运的是，我們很容易指出从用户的角度想要使用哪些字段搜索，並通过@SearchKey 注解完成。只需编辑 CommercialDocument 类（记住，它是 Order 和 Invoice 的父类）并将该注解添加到 year 和 number 属性：
      <pre><code class="java">abstract public class CommercialDocument extends Deletable {

    @SearchKey // Add this annotation here
    @Column(length=4)
    @DefaultValueCalculator(CurrentYearCalculator.class) 
    int year;

    @SearchKey // Add this annotation here 
    @Column(length=6)
    @ReadOnly
    int number;
	
    ...
	
}
</code></pre> 这样，当用户从参照搜索订单或发票时，他必须输入年份和编号，然後相应的实体将从数据库中填充至用户界面。<br>
      现在，用户无需使用搜索列表即可轻松选择发票，只需輸入年份和编号即可。
      <h3><a name="refining-action-for-searching-reference-typing-key"></a>优化输入键时的搜索</h3>
      现在可以使用年份和编号搜索发票，但我们希望对其进行改进，以帮助我们的用户更有效地完成工作。例如，如果用户尚未为订单选择客户并且他选择了发票，则该发票的客户将自动分配给当前订单，这會很方便。在下图可看到我們想要的行为：<br>
      <img src="files/references-collections_en040.png" alt="references-collections_en040.png"
        title="references-collections_en040.png"><br>
      另一方面，如果用户已经为订单选择了客户，但他跟发票的不一样，则会被拒绝并显示消息错误，像这样：</div>
    <img src="files/references-collections_en050.png" alt="references-collections_en050.png"
      title="references-collections_en050.png"><br>
    <div class="wiki" style="display: block;"> 为了定义这种特殊行为，我们必须在 Order 的 invoice 參照中添加 @OnChangeSearch 注解。 @OnChangeSearch 允许您定义自己的動作以當用户界面中的键更改时搜索。您可以在此处查看修改后的参照：
      <pre><code class="java">public class Order extends CommercialDocument {
 
    @ManyToOne
    @ReferenceView("NoCustomerNoOrders") 
    @OnChange(ShowHideCreateInvoiceAction.class)
    @OnChangeSearch(OnChangeSearchInvoiceAction.class) // Add this annotation
    @SearchAction("Order.searchInvoice")
    Invoice invoice;
	
    ...
	
}	
</code></pre> 从现在开始，当用户输入发票的新年份和编号时，将执行 OnChangeSearchInvoiceAction 的逻辑。此動作會从数据库中读取发票数据并更新用户界面。以下是動作的代码：
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import java.util.*;
import org.openxava.actions.*; // To use OnChangeSearchAction
import org.openxava.model.*;
import org.openxava.view.*;
import com.yourcompany.invoicing.model.*;

public class OnChangeSearchInvoiceAction 
    extends OnChangeSearchAction { // Standard logic for searching a reference when
                                   // the key values change in the user interface (1)
    public void execute() throws Exception {
        super.execute(); // It executes the standard logic (2)
        Map keyValues = getView()// getView() here is the reference view, not the main one (3)
            .getKeyValuesWithValue();
        if (keyValues.isEmpty()) return; // If key is empty no additional logic is executed
        Invoice invoice = (Invoice) // We search the Invoice entity from the typed key (4)
            MapFacade.findEntity(getView().getModelName(), keyValues);
        View customerView = getView().getRoot().getSubview("customer"); // (5)
        int customerNumber = customerView.getValueInt("number");
        if (customerNumber == 0) { // If there is no customer we fill it (6)
            customerView.setValue("number", invoice.getCustomer().getNumber());
            customerView.refresh();
        } 
        else { // If there is already customer we verify that he matches the invoice customer (7)
            if (customerNumber != invoice.getCustomer().getNumber()) {
                addError("invoice_customer_not_match", 
                    invoice.getCustomer().getNumber(), invoice, customerNumber);
                getView().clear();
            }
        }
    }
}	
</code></pre> 鉴于该動作从 OnChangeSearchAction (1) 扩展而来，并且我们使用 super.execute() (2)，它的行为只是标准方式，也就是当用户輸入年份和编号时，发票的数据會填充側用户界面。之后，我们使用 getView() (3) 获取所顯示发票的 key 以使用 MapFacade (4) 找到对应的实体。从 OnChangeSearchAction getView() 内部返回是參照的子视图，而不是全局视图。因此，在这种情况下 getView() 是参照发票的视图。这允许您创建更多可重用的 @OnChangeSearch 動作。因此，您必须编写 getView().getRoot().getSubview("customer") (5) 才能访问客户视图。<br>
      为了实现上图的行为，動作會询问是否沒有客户 (customberNumber == 0) (6)。如果是这种情况，它会从发票的客户中填写客户。否则，它会执行上图中的逻辑，以验证当前订单的客户是否与发票的客户匹配。<br>
      最后的细节是消息。将以下条目添加到 src/main/resources/i18n 文件夹中的 invoicing-messages_en.properties 文件。
      <pre><code class="properties">invoice_customer_not_match=发票 {1} 的客户编号 {0} 与当前订单的客户编号 {2} 不匹配
</code></pre> @OnChangeSearch 的有趣之处在于，当从列表中选发票时也会执行，因为在这种情况下，发票的年份和编号也会发生变化。因此，这是一个優化參照並填充视图的逻辑。
      <h2><a name="refining-collection-behavior"></a>优化集合的行为</h2>
      我们可以像優化參照一样優化集合。这非常有用，因为它允许我们改进 Invoice 模块當前的行为。如果发票和订单属于同一客户，用户才能将订单添加到发票中。此外，订单必须已送達，并且必须没有发票。
      <h3><a name="refining-the-list-for-adding-elements-to-a-collection"></a>优化将元素添加到集合的列表</h3>
      当前，当用户想将订单添加到发票时，所有订单都可選取。我们将对此进行改进，以仅显示該发票的客户的订单，並且已送達而尚未開发票，如下图所示：<br>
      <img src="files/references-collections_en60.png" alt="references-collections_en60.png"
        title="references-collections_en60.png"><br>
      我们将使用@AddAction 注解来定义我们自己的動作以显示添加订单的列表。以下代码是 Invoice 类中所需的修改。
      <pre><code class="java">public class Invoice extends CommercialDocument {

    @OneToMany(mappedBy="invoice")
    @CollectionView("NoCustomerNoInvoice")
    @AddAction("Invoice.addOrders") // To define our own action to add orders
    Collection&lt;Order&gt; orders;

    ...
	
}
</code></pre> In this simple way we define the action to execute when the user clicks on the button to add orders. The argument used for <i>@AddAction</i>, <i>Invoice.addOrders</i>, is the qualified name of the action, that is the action <i>addOrders</i> of the controller <i>Invoice</i> as defined in <i> controllers.xml</i> file. <br>
      Now we have to edit <i>controllers.xml</i> to add the <i>Invoice</i> controller (it does not exist yet) definition with our new action:
      <pre><code class="xml">&lt;controller name="Invoice"&gt;
    &lt;extends controller="Invoicing"/&gt;

    &lt;action name="addOrders"
        class="com.yourcompany.invoicing.actions.GoAddOrdersToInvoiceAction"
        hidden="true" icon="table-row-plus-after"/&gt;
        &lt;!--
        hidden="true" : Because we don't want the action to be shown in module button bar
        icon="table-row-plus-after" : The same icon as for the standard action
        --&gt;

&lt;/controller&gt;
</code></pre>This is the action code:
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import org.openxava.actions.*; // To use GoAddElementsToCollectionAction

public class GoAddOrdersToInvoiceAction
    extends GoAddElementsToCollectionAction { // Standard logic to go to
                                              // adding collection elements list
    public void execute() throws Exception {
        super.execute(); // It executes the standard logic, that shows a dialog
        int customerNumber =
            getPreviousView() // getPreviousView() is the main view (we are in a dialog)
                .getValueInt("customer.number"); // Reads the customer number
                                                 // of the current invoice from the view
        getTab().setBaseCondition( // The condition of the orders list to add
            "${customer.number} = " + customerNumber +
            " and ${delivered} = true and ${invoice} is null"
        );
    }
}
</code></pre> Note how we use <i>getTab().setBaseCondition()</i> to establish a condition for the list to choose the entities to add. That is, from a <i> GoAddElementsToCollectionAction</i> you can use <i>getTab()</i> to manipulate the way the list behaves.
      <h3><a name="refining-the-action-to-add-elements-to-a-collection"></a>优化将元素添加到集合的动作</h3>
      A useful improvement for the orders collection would be that when the user adds orders to the current invoice, the detail lines of those orders will be copied automatically to the invoice.<br>
      We cannot use the <i>@AddAction</i> for this, because it is the action to show the list to add elements to the collection. But this is not the action that adds the elements. <br>
      Let's learn how to define the action that actually adds the elements: <br>
      <img src="files/references-collections_en70.png" alt="references-collections_en70.png"
        title="references-collections_en70.png"><br>
      Unfortunately, there is not an annotation to directly define this 'Add' action. However, that is not a very difficult task, we only have to refine the <i>@AddAction</i> instructing it to show our own controller, and in this controller we can put the actions we want. Given we already have defined our <i>@AddAction</i> in the previous section we only have to add a new method to the already existing <i>GoAddOrdersToInvoiceAction</i> class. Add the next <i>getNextController()</i> method to your action:
      <pre><code class="java">public class GoAddOrdersToInvoiceAction ... {

    ...

    public String getNextController() { // We add this method
        return "AddOrdersToInvoice"; // The controller with the available actions
    }                                // in the list of orders to add
}
</code></pre> By default the actions in the list of entities to add (the ADD and CANCEL buttons) are from the standard OpenXava controller <i>AddToCollection</i>. Overwriting <i>getNextController()</i> in our action allows us to define our own controller instead. Add the next definition in <i>controllers.xml</i> for our custom controller for adding elements:
      <pre><code class="xml">&lt;controller name="AddOrdersToInvoice"&gt;
    &lt;extends controller="AddToCollection" /&gt; &lt;!-- Extends from the standard controller --&gt;
	
    &lt;!-- Overwrites the action to add --&gt;
    &lt;action name="add"
        class="com.yourcompany.invoicing.actions.AddOrdersToInvoiceAction" /&gt;
		
&lt;/controller&gt;
</code></pre> In this way the action to add orders to the invoice is <i>AddOrdersToInvoiceAction</i>. Remember that the goal of our action is to add the orders to the invoice in the usual way, but also to copy the detail lines from those orders to the invoice. This is the code of the action:<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import java.rmi.*;
import java.util.*;
import javax.ejb.*;
import org.openxava.actions.*; // To use AddElementsToCollectionAction
import org.openxava.model.*;
import org.openxava.util.*;
import org.openxava.validators.*;
import com.yourcompany.invoicing.model.*;

public class AddOrdersToInvoiceAction
    extends AddElementsToCollectionAction { // Standard logic for adding
                                            // collection elements
    public void execute() throws Exception {
        super.execute(); // We use the standard logic "as is"
        getView().refresh(); // To display fresh data, including recalculated
    }                        // amounts, which depend on detail lines

    protected void associateEntity(Map keyValues) // The method called to associate
        throws ValidationException, // each entity to the main one, in this case to
            XavaException, ObjectNotFoundException,// associate each order to the invoice
            FinderException, RemoteException
    {
        super.associateEntity(keyValues); // It executes the standard logic (1)
        Order order = (Order) MapFacade.findEntity("Order", keyValues); // (2)
        order.copyDetailsToInvoice(); // Delegates the main work to the entity (3)
    }
}
</code></pre> We overwrite the <i>execute()</i> method only to refresh the view after the process. Really, we want to refine the logic for associating an order to the invoice. The way to do this is overwriting the <i>associateEntity()</i> method. The logic here is simple, after executing the standard logic (1) we search the corresponding <i>Order</i> entity and then call the <i>copyDetailsToInvoice()</i> in that <i>Order</i>. Luckily we already have a method to copy details from an <i>Order</i> to the specified <i>Invoice</i>, we just call this method. </div>
    <div class="wiki" style="display: block;">Now you only have to create a new invoice, choose a customer and add orders. It is even easier than using the list mode of <i>Order</i> module because from <i>Invoice</i> module only the suitable orders for the customer are shown.
      <h2><a name="summary"></a>总结</h2>
      This lesson has shown you how to refine the standard behavior of references and collections in order for your application to fit the users needs. Here you only have seen some illustrative examples, but OpenXava provides many more possibilities for refining collections and references, such as the next annotations: <i>@ReferenceView, @ReadOnly, @NoFrame, @NoCreate, @NoModify, @NoSearch, @AsEmbedded, @SearchAction, @DescriptionsList, @LabelFormat, @Action, @OnChange, @OnChangeSearch, @Editor, @CollectionView, @EditOnly, @ListProperties, @RowStyle, @EditAction, @ViewAction, @NewAction, @SaveAction, @HideDetailAction, @RemoveAction, @RemoveSelectedAction, @ListAction, @DetailAction</i> and <i>@OnSelectElementAction</i>. Look at the <a
        href="view_en.html#View-Reference%20customization">Reference customization</a> and <a
        href="view_en.html#View-Collection%20customization">Collection customization</a> sections of reference guide.<br>
      And if that wasn't enough you always have the option of <a href="customizing_en.html">defining your own editor</a> for references or collections. Editors allows you to create a custom user interface component for displaying and editing the reference or collection. <br>
      This flexibility allows you to use automatic user interfaces for practically any possible case in real life business applications. </div>
    <br>
    <strong><a class="wiki_link_ext" href="https://github.com/openxava/openxava-course_en/tree/lesson-26"
        rel="nofollow">下载本课源代码</a></strong><strong><a class="wiki_link_ext"
        href="https://github.com/openxava/openxava-course_en/tree/lesson-26"
        rel="nofollow"></a></strong><br>
    <div class="wiki" style="display: block;"> <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"
          rel="nofollow">Ask in the forum</a></strong><strong></strong> </div>
  </body>
</html>
