<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title> Lesson 25: Behavior &amp; business logic - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1><a name="business-logic-behavior"></a> <span id="breadcrumbs"> <span
            id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava </a> </span> / <a
            href="index_zh.html">文档</a> / </span>第二十五章：行为与业务逻辑</h1>
      <strong>课程：</strong><a class="wiki_link" href="getting-started_zh.html">1. 入门教学</a> | <a
        class="wiki_link" href="basic-domain-model1_zh.html">2. 基本域模型（上）</a> | <a
        class="wiki_link" href="basic-domain-model2_zh.html">3. 基本域模型（下）</a> | <a
        class="wiki_link" href="refining-user-interface_zh.html">4. 优化用户界面</a> | <a
        class="wiki_link" href="agile-development_zh.html">5. 敏捷开发</a> | <a
        class="wiki_link" href="mapped-superclass-inheritance_zh.html">6. 映射式超类继承</a> | <a
        class="wiki_link" href="entity-inheritance_zh.html">7. 实体继承</a> | <a
        class="wiki_link" href="view-inheritance_zh.html">8. 视图继承（View）</a> | <a
        class="wiki_link" href="java-properties_zh.html">9. Java 属性</a> | <a
        class="wiki_link" href="calculated-properties_zh.html">10. 计算属性</a> | <a
        class="wiki_link" href="defaultvaluecalculator-in-collections_zh.html">11. 用在集合的 @DefaultValueCalculator</a><strong> </strong> | <a
        class="wiki_link" href="calculation-and-collections-total_zh.html">12. @Calculation 和集合总计</a> | <a
        class="wiki_link" href="defaultvaluecalculator-from-file_zh.html">13. 从外部文件的 @DefaultValueCalculator</a> | <a
        class="wiki_link" href="manual-schema-evolution_zh.html">14. 手动更改 schema</a> <a
        class="wiki_link" href="manual-schema-evolution_en.html"></a> | <a
        class="wiki_link" href="multi-user-default-value-calculation_zh.html">15. 多用户时默认值的计算</a> | <a
        class="wiki_link" href="synchronize-persistent-and-computed-properties_zh.html">16. 同步持久属性和计算属性</a> | <a
        class="wiki_link" href="logic-from-database_zh.html">17. 从数据库中的逻辑</a> |<span
        style="color: #0000ee;"> </span><a class="wiki_link" href="validating-with-entityvalidator_zh.html">18. 使用 @EntityValidator 进行验证</a> | <a
        class="wiki_link" href="validation-alternatives_zh.html">19. 验证替代方案</a> | <a
        class="wiki_link" href="validation-on-remove_zh.html">20. 删除时验证</a> | <a
        class="wiki_link" href="custom-bean-validation-annotation_zh.html">21. 自定义 Bean Validation 注解</a> | <a
        class="wiki_link" href="rest-service-call-from-validation_zh.html">22. 在验证中调用 REST 服务</a> | <a
        class="wiki_link" href="attributes-in-annotations_zh.html">23. 注解中的属性</a> | <a
        class="wiki_link" href="refining-standard-behavior_zh.html">24. 改进标准行为</a> | <strong>25. 行为与业务逻辑</strong> | <a
        class="wiki_link" href="references-collections_zh.html">26. 参照与集合</a> | <a
        class="wiki_link" href="philosophy_en.html">A. Architecture &amp; philosophy</a> | <a
        class="wiki_link" href="jpa_en.html">B. Java Persistence API</a> | <a
        class="wiki_link" href="annotations_en.html">C. Annotations</a> | <a
        class="wiki_link" href="testing_en.html">D. Automated testing</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">目录</h1>
        <div style="margin-left: 1em;"><a href="#business-logic-behavior">第二十五章：行为与业务逻辑<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#business-logic-in-detail-mode">详细模式的业务逻辑</a></div>
        <div style="margin-left: 3em;"><a href="#creating-an-action-for-custom-logic">创建执行自定义逻辑的动作</a></div>
        <div style="margin-left: 3em;"><a href="#writing-the-real-business-logic-in-the-entity">将真正的业务逻辑编写在实体中</a></div>
        <div style="margin-left: 3em;"><a href="#write-less-code-using-apache-commons-beanutils">使用 Apache Commons BeanUtils 以编写更少的代码</a></div>
        <div style="margin-left: 3em;"><a href="#copying-a-collection-from-entity-to-entity">运行时的异常</a></div>
        <div style="margin-left: 3em;"><a href="#validation-from-action">在动作中验证</a></div>
        <div style="margin-left: 3em;"><a href="#on-change-event-to-hide-show-an-action-programmatically">使用 OnChange 事件来隐藏/显示一个动作</a></div>
        <div style="margin-left: 2em;"><a href="#business-logic-from-list-mode">列表模式的业务逻辑</a></div>
        <div style="margin-left: 3em;"><a href="#list-action-with-custom-logic">在列表使用自定义逻辑的动作</a></div>
        <div style="margin-left: 3em;"><a href="#business-logic-in-the-model-over-several-entities">模型中多个实体的业务逻辑</a></div>
        <div style="margin-left: 2em;"><a href="#Showing-a-dialog">显示对话框</a></div>
        <div style="margin-left: 3em;"><a href="#using-showdialog">使用 showDialog()</a></div>
        <div style="margin-left: 3em;"><a href="#define-the-dialog-actions">定义对话框的动作</a></div>
        <div style="margin-left: 3em;"><a href="#closing-dialog">关闭对话框</a></div>
        <div style="margin-left: 3em;"><a href="#plain-view-instead-of-dialog">普通视图而不是对话框</a></div>
        <div style="margin-left: 2em;"><a href="#summary">总结</a></div>
      </div>
      OpenXava 不仅仅是一个用於 CRUD 的框架，而是用于开发成熟业务应用程序的框架。到目前为止，我们已经学到如何创建和優化应用程序以用於管理数据。我们现在將提供用户执行特定业务逻辑的可能性，来进一步改進应用程序。<br>
      在本章，我们将了解如何在模型編寫业务逻辑並從自定義的動作調用它們。由此，您可以将一個管理数据的应用程序转变为用户在日常工作中非常好使的工具。<br>
      <h2><a name="business-logic-in-detail-mode"></a>详细模式的业务逻辑</h2>
      我们将从最简单的情况开始：在详细模式中执行某逻辑的按钮。在这裡，我们将添加一个从订单创建发票的按钮：<br>
      <img src="files/business-logic-behavior_en010.png" alt="business-logic-behavior_en010.png"
        title="business-logic-behavior_en010.png"><br>
      以上显示了此動作如何使用当前订单创建发票，它只是将订单中的数据包括详细信息都复制到新的发票裡。之後會显示一条消息，而在订单中的发票分页将显示剛创建的发票。让我们看看如何实现这一点。
      <h3><a name="creating-an-action-for-custom-logic"></a>创建执行自定义逻辑的动作</h3>
      正如您所知道的，在模塊使用自定義動作的第一步是為該動作定義一個控制器。让我们在 controllers.xml 添加一个新的控制器。以下可看 Order 控制器的代碼：
      <pre><code class="xml">&lt;controller name="Order"&gt;
    &lt;extends controller="Invoicing"/&gt; &lt;!-- 为了有基本的动作 --&gt;
    
    &lt;action name="createInvoice" mode="detail"
        class="com.yourcompany.invoicing.actions.CreateInvoiceFromOrderAction"/&gt;
    &lt;!-- mode="detail" : 仅在详细模式下 --&gt;
    
&lt;/controller&gt;
</code></pre> 由于我们遵循在控制器使用与实体和模块相同的名称，因此您能在 Order 使用這新動作。Order 控制器從 Invoicing 控制器扩展。還記得我们在上一章创建了 Invoicing 控制器嗎，它是從 Typical 控制器改进的。<br>
      现在我们必须为这个动作编写 Java 代码：
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In 'actions' package

import org.openxava.actions.*;
import com.yourcompany.invoicing.model.*;

public class CreateInvoiceFromOrderAction
    extends ViewBaseAction { // To use getView()

    public void execute() throws Exception {
        Order order = (Order) getView().getEntity(); // Order entity displayed in the view (1)    
        order.createInvoice(); // The real work is delegated to the entity (2)
        getView().refresh(); // In order to see the created invoice in 'Invoice' tab (3)
        addMessage("invoice_created_from_order", // Confirmation message (4)
            order.getInvoice());
    }
}
</code></pre> 真的很简单。我们在(1)獲得 Order 实体後，调用 createInvoice() 方法 (2)，之後刷新视图 (3) 并显示一条消息 (4)。可以看到，動作只是视图（用户界面）和模型（业务逻辑）间的中介。<br>
      記得將以下消息添加到 <i>src/main/resources/i18n</i> 文件夾中的 <i>invoicing-messages_zh.properties</i>：<br>
      <pre><code class="properties">invoice_created_from_order=根据当前订单创建发票 {0}
</code></pre> 然而，這條消息并没有很好地显示，因为我们是传递了一个 Invoice 对象作为参数。所以我们需要一个对用户有用的 Invoice 和 Order toString()。我们将覆盖 CommercialDocument（Invoice 和 Order 的父级）的 toString() 来实现这一点。你可以在这里看到这个 toString() 方法：
      <pre><code class="java">abstract public class CommercialDocument extends Deletable {

    ...

    public String toString() {
        return year + "/" + number;
    }
}
</code></pre> 年份和数字非常适合从用户角度识别发票或订单。<br>
      让我们看看缺少的部分， Order 实体的 createInvoice() 方法。<br>
      <h3><a name="writing-the-real-business-logic-in-the-entity"></a>将真正的业务逻辑编写在实体中</h3>
      创建新发票的业务逻辑在 Order 实体中定义，而不是在動作中。自然得這麼做，因為面向对象的基本原则是对象不仅仅是数据，而是数据和逻辑。一個漂亮的代码，它的对象裡也都包含管理該對象数据的逻辑。如果您的实体仅仅是数据的容器（数据库表一個简单的包装），而您的動作包含它们的所有逻辑，那么您的代码就是在褻瀆面向对象的原則。<br>
      除了精神上的原因，将创建发票的逻辑放在 Order 实体中是一种非常实用的方法，因为这样我们可以从其它動作、批量处理、Web 服务等使用这个逻辑。<br>
      讓我們看看 Order 中的 createInvoice() 代码：
      <pre><code class="java">public class Order extends CommercialDocument {

    ...
    
    public void createInvoice() throws Exception { // throws Exception is just
                                                   // to get simpler code for now
        Invoice invoice = new Invoice(); // Instantiates an Invoice (1)
        BeanUtils.copyProperties(invoice, this); // and copies the state (2)
                                                 // from the current Order
        invoice.setOid(null); // To let JPA know this entity does not exist yet
        invoice.setDate(LocalDate.now()); // The date for the new invoice is today
        invoice.setDetails(new ArrayList&lt;&gt;(getDetails())); // Clones the details collection
        XPersistence.getManager().persist(invoice);
        this.invoice = invoice; // Always after persist() (3)
    }
}
</code></pre> 此逻辑就是创建一个新的 Invoice 对象 (1)、将数据从当前的 Order 中复制到它 (2) 并将成果实体给当前 Order 中的发票引用 (3)。<br>
      这里有三个微妙的细节。首先，您必须编写 invoice.setOid(null)，否则新的 Invoice 将與原 Order 获得相同的編號。此外，JPA 不喜欢使用自动生成並预先填充的 id 作為持久化对象。其次，您必须在调用 persist（发票）后将新的发票分配给当前订单（this.invoice = invoice），否则您会从 JPA 收到错误（类似于 “object references an unsaved transient instance”。第三，我们必须用 new ArrayList() 包装 details 集合，所以它是一个新集合但具有相同的元素，因为 JPA 不希望将相同的集合分配给两个实体。<br>
      <h3><a name="write-less-code-using-apache-commons-beanutils"></a>使用 Apache Commons BeanUtils 以编写更少的代码</h3>
      您可以看到我们如何使用 BeanUtils.copyProperties() 将所有属性从当前订单复制到新的发票。此方法将所有相同名称的属性从一个对象复制到另一个对象，即使这些对象属于不同的类。這程序来自 Apache 的 Commons BeanUtils。此实用程序的 jar commons-beanutils.jar 已包含在您的项目中。<br>
      以下展示了為何 BeanUtils 能讓您编写更少的代码：
      <pre><code class="java">BeanUtils.copyProperties(invoice, this);
// 如编写这些一样
invoice.setOid(getOid());
invoice.setYear(getYear());
invoice.setNumber(getNumber());
invoice.setDate(getDate());
invoice.setDeleted(isDeleted());
invoice.setCustomer(getCustomer());
invoice.setVatPercentage(getVatPercentage());
invoice.setVat(getVat());
invoice.setTotalAmount(getTotalAmount());
invoice.setRemarks(getRemarks());
invoice.setDetails(getDetails());
</code></pre> 不過，使用 BeanUtils 的主要优点不是节省編寫的時間，而是讓您的代码对更改更具弹性。因为，如果您添加、删除或重命名 ComercialDocument（Invoice 和 Order 的父级）的某些属性時，则无需更改代码也能繼續運行，而如果您手动复制属性，则必须手动更改那些代码。
      <h3><a name="copying-a-collection-from-entity-to-entity"></a>运行时的异常</h3>
      請记住这句话：“证明规则的异常”。规则、生活和软件都充满了异常。我们的 createInvoice() 方法也不例外。我们已经编写了在最常见情况下工作的代码。但是，如果订单还没有准备好开發票，或者访问数据库时出现问题時会发生什么？显然，在这些情况下，我们需要采取不同的路径。<br>
      也就是说，我们在 createInvoice() 编写的 throws Exception 不足以應對更細節的行为。所以应该使用我們自己的异常：
      <pre><code class="java">package com.yourcompany.invoicing.model; // In model package

import org.openxava.util.*;

public class CreateInvoiceException extends Exception { // Not RuntimeException

    public CreateInvoiceException(String message) {
        // The XavaResources is to translate the message from the i18n entry id
        super(XavaResources.getString(message)); 
    }
	
}
</code></pre>现在我们可以在 Order 的 createInvoice() 方法中使用我们的 CreateInvoiceException 而不是 Exception：
      <pre><code class="java">public void createInvoice()
    throws CreateInvoiceException // An application exception (1)
{
    if (this.invoice != null) { // If an invoice is already present we cannot create one
        throw new CreateInvoiceException( 
            "order_already_has_invoice"); // Allows an i18n id as argument
    }
    if (!isDelivered()) { // If the order is not delivered we cannot create the invoice
        throw new CreateInvoiceException("order_is_not_delivered");
    }
    try {
        Invoice invoice = new Invoice(); 
        BeanUtils.copyProperties(invoice, this); 
        invoice.setOid(null); 
        invoice.setDate(LocalDate.now()); 
        invoice.setDetails(new ArrayList&lt;&gt;(getDetails())); 
        XPersistence.getManager().persist(invoice);
        this.invoice = invoice; 
    }
    catch (Exception ex) { // Any unexpected exception (2)
        throw new SystemException( // A runtime exception is thrown (3)
            "impossible_create_invoice", ex);
    }
}
</code></pre>现在我们明确的声明此方法該抛出哪個异常 (1)。应用程序异常是经过检查的异常，也就是雖然它的行為特殊但在预期內。应用程序异常与方法的业务逻辑有关。您可以为每個可能的情况创建应用程序异常，例如 OrderAlreadyHasInvoiceException 和 OrderNotDeliveredException。这使您能够使用代码去以不同的方式处理每种异常情况。但我們並不需要，所以我们在這模塊使用通用的应用程序异常 CreateInvoiceException。<br>
      此外，我们必须处理意想不到的问题（2）。意外问题有可能是系统错误（数据库访问、网络或硬件问题）或程序员的错误（NullPointerException、IndexOutOfBoundsException 等）。当我们发现任何意外问题时，我们会抛出运行时异常（RuntimeException） (3)。在这个例子為了方便，我们抛出了 SystemException，一个 OpenXava 包含的运行异常，但您可以抛出任何想要的运行时异常。<br>
      您无需修改​​動作代码。如果您的動作不捕获异常，OpenXava 会自动执行。它會向用户显示来自应用程序异常的消息，对于运行时异常會显示通用的错误消息，并停止。<br>
      我们必须在 i18n 文件中添加用于异常的消息。請在 <i>src/main/resources/i18n</i> 文件夾中的 <i>invoicing-messages_zh.properties</i> 文件中添加以下：
      <pre><code class="properties">order_already_has_invoice=订单已有发票
order_is_not_delivered=订单未送达
impossible_create_invoice=无法创建发票
</code></pre> 在开发人员中一直存在关于在 Java 中异常的正确使用方法的争论。本节使用的方法的在 Java Enterprise 世界中处理异常的经典方法。
      <h3><a name="validation-from-action"></a>在动作中验证</h3>
      通常验证的最佳位置是在模型，也就是在实体。但是，有时需要将验证逻辑放在動作中。例如，如果要获取用户界面的当前状态，则必须从動作进行验证。<br>
      在我们的例子中，如果用户在创建一个新订单时点击了 CREATE INVOICE，但是这个订单还没有被保存，它将会失败。原因是因为不能从不存在的订单去创建发票。因此用户必须先保存订单。<br>
      为此，我們在 CreateInvoiceFromOrderAction 的 execute() 方法的开头添加一个条件，以验证当前显示的订单是否已保存：
      <pre><code class="java">public void execute() throws Exception {
    // Add the next condition       
    if (getView().getValue("oid") == null) { 
        // If oid is null the current order is not saved yet (1)
        addError("impossible_create_invoice_order_not_exist");
        return;
    }
    
    ...
    
}
</code></pre> 此验证會查看 oid 是否为空 (1)，當用户正在输入新订单，但他尚未保存時 oid 是空的。在这种情况下，会显示一条消息，并且发票的创建將被中止。<br>
      这里我们还有一条消息要添加到 i18n 文件中。请编辑 src/main/resources/i18n 文件夹中的 invoicing-messages_zh.properties 文件，添加以下条目：
      <pre><code class="properties">impossible_create_invoice_order_not_exist=无法创建发票：订单尚不存在
</code></pre> 验证會告诉用户他做错了什么。这当然是必要的，但更好的是创建一个能帮助用户避免任何错误行为的应用程序。让我们在下一节中看看如何做的一种方法。
      <h3><a name="on-change-event-to-hide-show-an-action-programmatically"></a>使用 OnChange 事件来隐藏/显示一个动作</h3>
      我们当前的代码足够防止用户因失误而破坏数据。但我们将更进一步，防止用户失誤。如果订单不應該开发票時，我们将隐藏创建新发票的動作。<br>
      OpenXava 允许自動隐藏和显示動作。也允許用户在界面更改某些属性时，自動执行某此動作。我们可以使用这两种技术仅在准备好使用时才显示動作的按钮。<br>
      请记住，仅当订单已送達且还没有发票时，才能从订单中生成发票。因此，我们必须监控订单实体的 invoice 引用和 delivered 属性的变化。首先，我们将使用以下代码创建一个動作来显示或隐藏从订单中创建发票的動作 ShowHideCreateInvoiceAction：<br>
      <pre><code class="java">package com.yourcompany.invoicing.actions; // In the 'actions' package

import org.openxava.actions.*; // Needed to use OnChangePropertyAction,

public class ShowHideCreateInvoiceAction
    extends OnChangePropertyBaseAction { // Needed for @OnChange actions (1)

    public void execute() throws Exception {
        if (isOrderCreated() &amp;&amp; isDelivered() &amp;&amp; !hasInvoice()) { // (2)
            addActions("Order.createInvoice");
        }
        else {
            removeActions("Order.createInvoice");
        }
    }
	
    private boolean isOrderCreated() {
        return getView().getValue("oid") != null; // We read the value from the view
    }
	
    private boolean isDelivered() {
        Boolean delivered = (Boolean)
            getView().getValue("delivered"); // We read the value from the view
        return delivered == null?false:delivered;
    }

    private boolean hasInvoice() {
        return getView().getValue("invoice.oid") != null; // We read the value from the view
    } 	
}
</code></pre> 然后我们用 @OnChange 注解 invoice 和 delivered，因此当用户在界面中更改 delivered 或 invoice 的值时，将执行 ShowHideCreateInvoiceAction：
      <pre><code class="java">public class Order extends CommercialDocument {

    ...
    @OnChange(ShowHideCreateInvoiceAction.class) // Add this
    Invoice invoice;

    ...
    @OnChange(ShowHideCreateInvoiceAction.class) // Add this
    boolean delivered;

    ...
}
</code></pre> ShowHideCreateInvoiceAction 是一个带有 execute() 方法的常规动作，不過它還從 OnChangePropertyBaseAction 扩展(1)。所有使用 @OnChange 注解的动作都必须实现 IOnChangePropertyAction，但是從已实现它的 OnChangePropertyBaseAction 扩展會容易些。从此動作，您可以使用 getNewValue() 和 getChangedProperty()，尽管在這例子我们不會用到它们。<br>
      execute() 方法是询问显示的订单是否已保存、已交付并且还没有发票 (2)，若都是，它会使用 addActions("Order.createInvoice") 显示该動作，相反它則会使用 removeActions 隐藏该動作（“Order.createInvoice”）。因此，我们仅在适用时显示 Order.createInvoice 動作。add/removeActions() 方法允许指定显示或隐藏多个動作，它們得以逗号分隔。<br>
      现在，当用户點擊 delivered 选框或选择发票时，將显示或隐藏該動作的按钮。而当用户點击新建按钮以创建新订单时，用于创建发票的按钮也會被隐藏。但是，如果您选择修改已存在的订单，则无论是否满足先决条件，该按钮始终存在。这是因为在搜索和显示对象时，默认情况下不会执行 @OnChange 操作。我们可以在 SearchExcludingDeleteAction 中稍作修改来改变这一点：
      <pre><code class="java">public class SearchExcludingDeletedAction
    // extends SearchByViewKeyAction {
    extends SearchExecutingOnChangeAction { // Use this as base class
</code></pre> 默认的搜索動作，也就是 SearchByViewKeyAction 默认下不會执行 @OnChange 操作，因此我们将搜索動作更改为从 SearchExecutingOnChangeAction 扩展。 SearchExecutingOnChangeAction 的行为类似于 SearchByViewKeyAction，但执行 OnChange 事件。这样，当用户选择订单时，就会执行 ShowHideCreateInvoiceAction。<br>
      還差一个微小的细节就完美了：当用户點击 CREATE INVOICE 时，並创建发票后，该按钮应该被隐藏，不能两次创建同一张发票。我们可以通过优化 CreateInvoiceFromOrderAction 来实现这个功能：
      <pre><code class="java">public void execute() throws Exception {

    ...

    // Everything worked fine, so we'll hide the action
    removeActions("Order.createInvoice"); 
}
</code></pre> 如您所见，我们只是在 execute() 方法的末尾添加了 removeActions("Order.createInvoice")。<br>
      显示和隐藏動作並不能替代模型中的验证。验证仍然是必要的，因为实体可能从应用程序的任何其他部分使用，而不仅仅是来自 CRUD 模块。然而，隐藏和显示动作的技巧改善了用户体验。
      <h2><a name="business-logic-from-list-mode"></a>列表模式的业务逻辑</h2>
      在上一章，您学到如何<a href="refining-standard-behavior_zh.html#Lesson%207:%20Refining%20the%20standard%20behavior-List%20mode-List%20actions">创建列表動作</a>。列表動作是非常有用的工具，它为用户提供了同时对多个对象执行特定逻辑的能力。在我们的例子中，我们可以在列表模式下添加一个動作，以从列表中选定的多個订单创建新发票。以这种方式工作：<br>
      <img src="files/business-logic-behavior_en020.png" alt="business-logic-behavior_en020.png"
        title="business-logic-behavior_en020.png"><br>
      此列表動作會從选定的订单中创建发票。它只是将订单数据复制到新发票中，将所有订单的詳情添加到一张唯一的发票中。还会显示一条消息。让我们看看如何為這行为編寫代碼。
      <h3><a name="list-action-with-custom-logic"></a>在列表使用自定义逻辑的动作</h3>
      正如您所知道的，在模塊使用自定義動作的第一步是將該動作添加到一個控制器中。因此，让我们编辑 controllers.xml 在 Order 控制器添加一个新動作：
      <pre><code class="xml">&lt;controller name="Order"&gt;

    ...
    
    &lt;!-- The new action --&gt;
    &lt;action name="createInvoiceFromSelectedOrders"
        mode="list"
        class="com.yourcompany.invoicing.actions.CreateInvoiceFromSelectedOrdersAction"/&gt;
	&lt;!-- mode="list": Only shown in list mode --&gt;

&lt;/controller&gt;
</code></pre> 这些就讓您在 Order 的列表模式下有新的動作。<br>
      现在我们必须为这个动作编写 Java 代码：
      <pre><code class="java">package com.yourcompany.invoicing.actions;

import java.util.*;
import javax.ejb.*;
import org.openxava.actions.*;
import org.openxava.model.*;
import com.yourcompany.invoicing.model.*;

public class CreateInvoiceFromSelectedOrdersAction
    extends TabBaseAction { // Typical for list actions. It allows you to use getTab() (1)

    public void execute() throws Exception {
        Collection&lt;Order&gt; orders = getSelectedOrders(); // (2)
        Invoice invoice = Invoice.createFromOrders(orders); // (3)
        addMessage("invoice_created_from_orders", invoice, orders); // (4)
    }

    private Collection&lt;Order&gt; getSelectedOrders() // (5)
        throws FinderException
    {
        Collection&lt;Order&gt; result = new ArrayList&lt;&gt;();
        for (Map key: getTab().getSelectedKeys()) { // (6)
            Order order = (Order) MapFacade.findEntity("Order", key); // (7)
            result.add(order);
        }
        return result;
    }
}
</code></pre> 這很简单。我们获取列表（2）中已選取的订单，调用 Invoice 的 createFromOrders() 静态方法（3）并显示消息（4）。在这种情况，我们还是將逻辑放在模型类，而不是在动作中。由于该逻辑适用于多个订单并创建新发票，因此把它放在 Invoice 类為静态方法是最自然的方法。<br>
      getSelectedOrders() 方法會返回一个集合(5)，裡包含用户在列表中選定的 Order 实体。而該方法(5)使用 getTab() 来实现(6)，getTab() 可从 TabBaseAction (1) 获得，它返回一个 org.openxava.tab 的 Tab 对象。Tab 对象允许您管理列表的表格数据。在这种情况下，我们使用 getSelectedKeys() (6) 來返回一个集合，裡包含所有选取行的键。由于这些键是 Map 格式，所以我们使用 MapFacade.findEntity() (7) 将它们转换为 Order 实体。<br>
      与往常一样，将消息添加到 src/main/resources/i18n 文件夹中的 invoicing-messages_zh.properties：
      <pre><code class="properties">invoice_created_from_orders=从订单 {1} 创建发票 {0}
</code></pre> 这就是動作的全部。让我们看看缺少的部分，也就是 Invoice 类的 createFromOrders() 方法。
      <h3><a name="business-logic-in-the-model-over-several-entities"></a>模型中多个实体的业务逻辑</h3>
      从多个订单实体创建新发票的业务逻辑在模型层（即实体）中，而不是在動作中。我们不能将方法放在 Order 类中，因为该过程是由多个订单完成的，而不仅仅是一个。我们不能在 Invoice 中使用实例方法，因为发票尚未存在，实际上我们想创建它。因此，我们将在 Invoice 类中创建一个静态工厂方法，用于从多个订单创建一個新发票。<br>
      你可以在下面看到方法：<br>
      <pre><code class="java">public class Invoice extends CommercialDocument {

    ...
	
    public static Invoice createFromOrders(Collection&lt;Order&gt; orders)
        throws CreateInvoiceException
    {
        Invoice invoice = null;
        for (Order order: orders) {
            if (invoice == null) { // The first order
                order.createInvoice(); // We reuse the logic for creating an invoice
                                       // from an order
                invoice = order.getInvoice(); // and use the created invoice
            }
            else { // For the remaining orders the invoice is already created
                order.setInvoice(invoice); // Assign the invoice
                order.copyDetailsToInvoice(); // A method of Order to copy the lines
            } 
        } 
        if (invoice == null) { // If there are no orders
            throw new CreateInvoiceException(
                "orders_not_specified");
        }
        return invoice;
    }
}
</code></pre> 我们在第一个 Order 時使用 Order 類中已经存在的 createInvoice() 方法創建新的 Invoice，然后我们调用 Order 的 copyDetailsToInvoice() 方法将剩余订单中的詳情复制到新的 Invoice 中，并在其上累积税額和價稅合計。此外，我们将新的 Invoice 设置为集合中所有订单的发票。<br>
      如果发票在流程结束时为空，那是因为订单集合为空。在这种情况下，我们將抛出一个 CreateInvoiceException。由于该動作没有捕获异常，OpenXava 會向用户显示异常消息。这是可以的。如果用户没有检查任何订单并且他點击了创建发票的按钮，那么會向他显示此错误消息。</div>
    <div class="wiki" style="display: block;">我们仍然需要在 Order 中添加 copyDetailsToInvoice() 方法：</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public class Order extends CommercialDocument {

    ...
	
    public void copyDetailsToInvoice() { 
        invoice.getDetails().addAll(getDetails()); // Copies the lines
        invoice.setVat(invoice.getVat().add(getVat())); // Accumulates the vat
        invoice.setTotalAmount( // and the total amount
            invoice.getTotalAmount().add(getTotalAmount())); 
    }
}
</code></pre> </div>
    <div class="wiki" style="display: block;">如您所见，它将当前订单的详细信息复制到发票并累积税額和價稅合計。</div>
    <div class="wiki" style="display: block;"> 请记住将消息添加到 src/main/resources/i18n 文件夹中的 invoicing-messages_zh.properties：
      <pre><code class="properties">orders_not_specified=未指定订单
</code></pre> 这並不是用户可能碰到的唯一異常。所有之前为 Invoice 和 Order 编写的验证都會自动執行。这會确保用户必须选择来自同一客户的订单、並且已交付、也未開发票等。模型中验证可防止用户從不該的订单创建发票。
      <h2><a name="Showing-a-dialog"></a>显示对话框</h2>
      从多个订单创建发票后，讓用户可以查看并编辑新建的发票會很方便。实现此目的的一种方法是显示一个对话框，並允许查看和编辑刚刚新建的发票。如下：<br>
      <img src="files/business-logic-behavior_en030.png" alt="business-logic-behavior_en030.png"
        title="business-logic-behavior_en030.png"><br>
      让我们看看如何实现这种行为。
      <h3><a name="using-showdialog"></a>使用 showDialog()</h3>
      第一步是修改 CreateInvoiceFromSelectedOrdersAction 以在创建发票后显示一个对话框，只需在 execute() 後添加几行代碼就可以：<br>
      <pre><code class="java">public void execute() throws Exception {
    Collection&lt;Order&gt; orders = getSelectedOrders(); 
    Invoice invoice = Invoice.createFromOrders(orders); 
    addMessage("invoice_created_from_orders", invoice, orders); 

    // Add the next lines to show the dialog
    showDialog(); // (1)
    // From now on getView() is the dialog
    getView().setModel(invoice); // Display invoice in the dialog (2)
    getView().setKeyEditable(false); // To indicate that is an existing object (3)
    setControllers("InvoiceEdition"); // The actions of the dialog (4)
}
</code></pre>我们调用 showDialog() (1)，它會显示一个对话框，在這之後当我们使用 getView() 时，它引用的是对话框中的视图，而不是模块的主视图。在 showDialog() 之后对话框是空白的，直到我们使用 getView().setModel(invoice) (2) 将发票分配给视图，现在发票显示在对话框中。下一行，getView().setKeyEditable(false) (3) 表示发票已经保存，所以之后对应的保存动作知道如何表现。最后，我们使用 setControllers("InvoiceEdition") 来定义在对话框中存在動作的控制器，也就是对话框底部的按钮。请注意，setControllers() 是 addActions() 的一種替代方法。<br>
      显然，在我们定义了 InvoiceEdition 控制器之前，这将不起作用。請看下一節。
      <h3><a name="define-the-dialog-actions"></a>定义对话框的动作</h3>
      The dialog allows the user to change the invoice and save the changes or just close the dialog after examining the invoice. These actions are defined in the <i>I&nbsp; nvoiceEdition</i> controller in <i>controllers.xml</i>:&nbsp; <br>
      <pre><code class="xml">&lt;controller name="InvoiceEdition"&gt;

    &lt;action name="save"
        class="com.yourcompany.invoicing.actions.SaveInvoiceAction"
        keystroke="Control S"/&gt;
		
    &lt;action name="close"
        class="org.openxava.actions.CancelAction"/&gt;
		
&lt;/controller&gt;
</code></pre> The two actions of this controller represent the two buttons, SAVE and CLOSE you saw in the previous image.</div>
    <div class="wiki" style="display: block;">
      <h3><a name="closing-dialog"></a>关闭对话框 </h3>
      <i>SaveInvoiceAction</i> contains just a minor extension of the standard <i>SaveAction</i> of OpenXava:
      <pre><code class="java">package com.yourcompany.invoicing.actions;

import org.openxava.actions.*;

public class SaveInvoiceAction
    extends SaveAction { // Standard OpenXava action to save the view content
	 
    public void execute() throws Exception {
        super.execute(); // The standard saving logic (1)
        closeDialog(); // (2)
    }
}
</code></pre> The action extends <i>SaveAction</i> overwriting the <i>execute()</i> method to just call to the standard logic, with <i>super.execute()</i> (1), and then to close the dialog with <i>closeDialog()</i> (2). In this way, when the user clicks on SAVE, the invoice data is saved and the dialog is closed, so the application returns to the list of orders, ready to continue the creation of invoices from orders.<br>
      For the CLOSE button we use the <i>CancelAction</i>, an action included in OpenXava that simply closes the dialog.
      <h3><a name="plain-view-instead-of-dialog"></a>普通视图而不是对话框</h3>
      Sometimes instead of showing a dialog on top:<br>
      <img src="files/business-logic-behavior_en040.png" alt="business-logic-behavior_en040.png"
        title="business-logic-behavior_en040.png"><br>
      You could prefer to replace the current view with a new one, thus: <br>
      <img src="files/business-logic-behavior_en050.png" alt="business-logic-behavior_en050.png"
        title="business-logic-behavior_en050.png"><br>
      This can be useful when the amount of data to show is huge and in a dialog looks clumsy. Using a plain view instead of a dialog is as easy as changing this line of from your <i>CreateInvoiceFromSelectedOrdersAction:</i>
      <pre><code class="java">showDialog();
</code></pre> By this one:
      <pre><code class="java">showNewView();
</code></pre> No more changes are needed. Well, maybe changing the name of the "close" action to "return" in <i>InvoiceEdition</i> controller in <i>controllers.xml</i>.<br>
      <br>
      Our work is done. If you try out the <i>Order</i> module, choose several orders, and click on the CREATE INVOICE FROM SELECTED ORDERS to see a dialog with the newly created invoice. Just as you saw in the image at the beginning of this section.
      <h2><a name="summary"></a>总结</h2>
      The salt of your application comes from the actions and entity methods. Thanks to them you can convert a simple data management application into a useful tool. In this lesson, for example, we provided the user with a way to automatically create invoices from orders.<br>
      You have learned how to create instance and static methods for business logic, and how to call them from actions in detail and list mode. Along the way you also saw how to hide and show actions, use exceptions, validating from actions, show dialogs and how to test all this.<br>
      We still have many interesting things to learn, in the next lesson for example we are going to refine the behavior of references and collections.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://github.com/openxava/openxava-course_en/tree/lesson-25"
          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"
          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine? <a
          class="wiki_link" href="references-collections_en.html">Go to Lesson 26</a></strong> </div>
  </body>
</html>
